<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr - Live Session Game</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
        }
        header {
            background-color: #0cc0df;
            padding: 20px;
            border-radius: 0 0 5px 5px;
        }
        h1 {
            color: #444;
            margin-top: 0;
        }
        main {
            padding: 20px;
            max-width: 1980px;
            margin: 0 auto;
        }
        section {
            margin-bottom: 30px;
        }
        
        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .status-connected { background: #d4edda; color: #155724; }
        .status-connecting { background: #fff3cd; color: #856404; }
        .status-disconnected { background: #f8d7da; color: #721c24; }
        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 60px;
            right: 10px;
            padding: 10px 15px;
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            color: #0c5460;
            font-size: 14px;
            z-index: 1000;
            max-width: 300px;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        /* Session Management Styles */
        .session-container {
            max-width: 600px;
            margin: 50px auto;
            padding: 30px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #f9f9f9;
            text-align: center;
        }
        .session-form {
            margin: 20px 0;
        }
        .session-form input {
            padding: 10px;
            margin: 10px;
            font-size: 1.1em;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 200px;
        }
        .session-form button {
            padding: 12px 30px;
            font-size: 1.1em;
            background-color: #0cc0df;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        .session-form button:hover {
            background-color: #0aa8c4;
        }
        .session-form button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .session-info {
            background-color: #e8f4f8;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .waiting-message {
            background-color: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border: 1px solid #ffeaa7;
        }
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }
        .success-message {
            background-color: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
        }
        
        /* Live Player List */
        .live-players {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: left;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background-color: white;
            border-radius: 3px;
            border-left: 4px solid #28a745;
        }
        .player-item.you {
            border-left-color: #007cba;
            background-color: #e6f3ff;
        }
        .player-item.left {
            border-left-color: #ffc107;
            background-color: #fff3cd;
        }
        .player-item.kicked {
            border-left-color: #dc3545;
            background-color: #f8d7da;
        }
        
        /* Game Styles */
        .game-container {
            display: none;
        }
        .maps-container {
            position: relative;
            height: 900px;
            width: 100%;
            margin-bottom: 20px;
            overflow: hidden;
        }
        #maptiler-map {
            position: relative;
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
            background-color: #eaeaea;
        }
        #overlay-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 500px;
            height: 300px;
            border: 2px solid #555;
            border-radius: 5px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 10;
            transition: all 0.4s ease-in-out;
        }
        #overlay-map:hover:not(.overlay-map-fullscreen) {
            width: 400px;
            height: 300px;
        }
        .overlay-map-fullscreen {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 100 !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }
        .submit-container {
            text-align: center;
            margin-bottom: 30px;
        }
        .submit-btn, .new-location-btn, .start-game-btn, .next-round-btn {
            background-color: #0cc0df;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 0 10px;
        }
        .submit-btn:hover, .new-location-btn:hover, .start-game-btn:hover, .next-round-btn:hover {
            background-color: #0aa8c4;
        }
        .submit-btn:disabled, .new-location-btn:disabled, .start-game-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* Live Leaderboard Styles */
        .leaderboard {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .leaderboard table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .leaderboard th, .leaderboard td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .leaderboard th {
            background-color: #0cc0df;
            color: white;
        }
        .leaderboard tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .leaderboard tr.current-player {
            background-color: #fff3cd !important;
            font-weight: bold;
        }
        
        footer {
            background-color: #0cc0df;
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            font-size: 0.9em;
            margin-top: 40px;
        }
        .maptiler-ctrl-group,
        .maptiler-ctrl,
        .maplibregl-ctrl-group,
        .maplibregl-ctrl {
            display: none !important;
        }
        .guess-pin, .real-location-pin {
            position: absolute;
            width: 24px;
            height: 36px;
            background-size: contain;
            background-repeat: no-repeat;
            transform: translate3d(-50%, -100%, 0);
            pointer-events: none;
        }
        .guess-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%23e53e3e" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            z-index: 101;
        }
        .real-location-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%2328a745" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            z-index: 102;
        }
        #next-round-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            font-size: 1.1em;
            background-color: #0cc0df;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 110;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        #next-round-btn:hover {
            background-color: #0aa8c4;
        }
        #round-score-display, #total-score-display {
            position: fixed;
            padding: 10px 15px;
            background-color: black;
            color: white;
            font-size: 1.2em;
            border-radius: 5px;
            z-index: 1000;
            display: none;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            border: 1px solid white;
        }
        #round-score-display {
            bottom: 20px;
            left: 20px;
        }
        #total-score-display {
            bottom: 20px;
            right: 20px;
        }
        
        /* Game Status */
        .game-status-bar {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
        }
        .status-value {
            font-weight: bold;
            font-size: 16px;
            color: #007cba;
        }
    </style>
</head>
<body>
    <div id="connectionStatus" class="connection-status status-connecting">
        <span class="live-indicator"></span>
        <span id="statusText">Not Connected</span>
    </div>
    
    <div id="notification" class="notification"></div>
    
    <header>
        <h1>Map Guessr - Live Session Game</h1>
        <p>Real-time Connected Multiplayer Experience</p>
    </header>
    <main>
        <!-- Session Join Screen -->
        <div id="session-join" class="session-container">
            <h2>Join Live Game Session</h2>
            <p>Enter your session code and player name to join the live game.</p>
            <div class="session-form">
                <input type="text" id="session-code" placeholder="Session Code" maxlength="10">
                <br>
                <input type="text" id="player-name" placeholder="Your Name" maxlength="30">
                <br>
                <button onclick="joinSession()" id="join-button">Join Live Session</button>
            </div>
            <div id="join-message"></div>
        </div>

        <!-- Session Waiting Screen -->
        <div id="session-waiting" class="session-container" style="display: none;">
            <h2>üî¥ Live Session Joined!</h2>
            <div id="session-info" class="session-info"></div>
            
            <div class="live-players">
                <h4>üë• Live Players</h4>
                <div id="players-list"></div>
            </div>
            
            <div class="waiting-message">
                <h3>‚è≥ Waiting for game to start...</h3>
                <p><strong>Live Status:</strong> Connected and waiting for administrator instructions</p>
                <p>You'll be automatically notified when the game becomes available!</p>
            </div>
            
            <div class="game-status-bar">
                <div class="status-item">
                    <span class="status-value" id="live-status">waiting</span>
                    <span>Status</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="live-players-count">0</span>
                    <span>Players</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="live-connections">0</span>
                    <span>Connected</span>
                </div>
            </div>
            
            <button class="start-game-btn" onclick="startGame()" id="start-button" style="display: none;">üéÆ Start Playing</button>
            <div id="wait-message"></div>
        </div>

        <!-- Game Screen -->
        <div id="game-container" class="game-container">
            <section>
                <h2>üéØ Live Game in Progress</h2>
                <div id="game-status" class="game-status-bar"></div>
                <div class="maps-container">
                    <div id="maptiler-map"></div>
                    <div id="overlay-map"></div>
                </div>
                <div class="submit-container">
                    <button class="submit-btn" id="submit-guess">Submit Guess</button>
                </div>
            </section>
            
            <section>
                <h2>üìä Game Progress</h2>
                <ul>
                    <li id="location-text">Waiting for location...</li>
                    <li id="guessed-coords">Make your guess on the overlay map...</li>
                    <li id="submit-status">Place your guess on the overlay map...</li>
                    <li id="points-score">Points: - | Total: 0 points</li>
                    <li id="round-count">Round: 1 | Game: 1</li>
                </ul>
            </section>

            <div id="leaderboard-container">
                <div class="leaderboard">
                    <h3>üèÜ Live Leaderboard</h3>
                    <div id="leaderboard-content">
                        <p>Waiting for scores...</p>
                    </div>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <p>Live WebSocket-Based Map Guessr Game</p>
    </footer>

    <div id="round-score-display"></div>
    <div id="total-score-display"></div>

    <script>
        // --- Configuration ---
        const API_BASE_URL = 'https://game-session-worker.games-6cb.workers.dev';
        const INITIAL_ZOOM_LEVEL = 15;
        const OVERLAY_INITIAL_CENTER = [0, 0];
        const OVERLAY_INITIAL_ZOOM = -0.5;
        const MAX_SCORE_PER_ROUND = 5000;
        const PERFECT_SCORE_THRESHOLD_METERS = 100;
        const SCORE_DECAY_FACTOR = 2000000;

        // --- Session State Variables ---
        let sessionCode = null;
        let playerName = null;
        let playerId = null;
        let sessionData = null;
        let currentRound = 1;
        let currentGame = 1;
        let gameWebSocket = null;
        
        // --- Game State Variables ---
        let mainMap = null;
        let overlayMap = null;
        let currentSdkMarker = null;
        let userGuessLngLat = null;
        let guessPinElement = null;
        let realLocationPinElement = null;
        let actualLocationCoords = null;
        let totalScore = 0;
        let lineLayerVisible = false;
        let gameInProgress = false;

        // --- DOM Element Cache ---
        const DOM = {};
        function cacheDOMElements() {
            DOM.sessionJoin = document.getElementById('session-join');
            DOM.sessionWaiting = document.getElementById('session-waiting');
            DOM.gameContainer = document.getElementById('game-container');
            DOM.sessionInfo = document.getElementById('session-info');
            DOM.waitMessage = document.getElementById('wait-message');
            DOM.joinMessage = document.getElementById('join-message');
            DOM.startButton = document.getElementById('start-button');
            DOM.locationText = document.getElementById('location-text');
            DOM.guessedCoordsText = document.getElementById('guessed-coords');
            DOM.submitStatusText = document.getElementById('submit-status');
            DOM.pointsScoreText = document.getElementById('points-score');
            DOM.roundCountText = document.getElementById('round-count');
            DOM.submitGuessBtn = document.getElementById('submit-guess');
            DOM.overlayMapElement = document.getElementById('overlay-map');
            DOM.roundScoreDisplay = document.getElementById('round-score-display');
            DOM.totalScoreDisplay = document.getElementById('total-score-display');
            DOM.mapsContainer = document.querySelector('.maps-container');
            DOM.leaderboardContainer = document.getElementById('leaderboard-container');
            DOM.leaderboardContent = document.getElementById('leaderboard-content');
            DOM.gameStatus = document.getElementById('game-status');
            DOM.playersListElement = document.getElementById('players-list');
            DOM.liveStatus = document.getElementById('live-status');
            DOM.livePlayersCount = document.getElementById('live-players-count');
            DOM.liveConnections = document.getElementById('live-connections');
            DOM.joinButton = document.getElementById('join-button');
        }

        // --- WebSocket Management ---
        class GameWebSocket {
            constructor(sessionCode) {
                this.sessionCode = sessionCode;
                this.ws = null;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectAttempts = 0;
                this.connect();
            }

            connect() {
                try {
                    updateConnectionStatus('connecting');
                    const WS_BASE_URL = 'wss://game-session-worker.games-6cb.workers.dev';
                    const wsUrl = `${WS_BASE_URL}/ws?session=${this.sessionCode}`;

                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        updateConnectionStatus('connected');
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 1000;
                        
                        // Request initial session update
                        this.send({ type: 'request_update' });
                        
                        // Send ping every 30 seconds
                        this.pingInterval = setInterval(() => {
                            if (this.ws?.readyState === WebSocket.OPEN) {
                                this.send({ type: 'ping' });
                            }
                        }, 30000);
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        updateConnectionStatus('disconnected');
                        if (this.pingInterval) {
                            clearInterval(this.pingInterval);
                        }
                        this.scheduleReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        updateConnectionStatus('disconnected');
                    };
                    
                } catch (error) {
                    console.error('Error creating WebSocket:', error);
                    updateConnectionStatus('disconnected');
                    this.scheduleReconnect();
                }
            }

            send(message) {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                } else {
                    console.warn('WebSocket not connected, message not sent:', message);
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'session_update':
                        handleSessionUpdate(message.data);
                        if (message.event) {
                            handleSessionEvent(message.event);
                        }
                        break;
                        
                    case 'join_success':
                        showNotification('Successfully joined the game!', 'success');
                        break;
                        
                    case 'score_success':
                        showNotification(`Score posted! Total: ${message.totalScore}`, 'success');
                        break;
                        
                    case 'session_deleted':
                        showNotification('Session was deleted by admin', 'error');
                        resetToJoinScreen();
                        break;
                        
                    case 'error':
                        showNotification(`Error: ${message.message}`, 'error');
                        break;
                        
                    case 'pong':
                        // Server responded to ping
                        break;
                        
                    case 'connected':
                        console.log('WebSocket:', message.message);
                        break;
                        
                    default:
                        console.log('Unknown message type:', message.type, message);
                }
            }
            
            scheduleReconnect() {
                if (!sessionCode) return; // Don't reconnect if we've left the session
                
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts), this.maxReconnectDelay);
                
                console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
                
                setTimeout(() => {
                    if (sessionCode) {
                        this.connect();
                    }
                }, delay);
            }

            close() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                }
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        // --- WebSocket Event Handlers ---
        function handleSessionUpdate(data) {
            sessionData = data;
            updateLiveSessionInfo();
            updateLivePlayersList();
            updateLiveLeaderboard();
            
            // Check if game state changed
            checkGameAvailability();
        }

        function handleSessionEvent(event) {
            let message = null;
            switch (event.type) {
                case 'player_joined':
                    message = `${event.playerName} joined the game`;
                    break;
                case 'player_left':
                    message = 'A player left the game';
                    break;
                case 'player_kicked':
                    message = `A player was kicked: ${event.reason || 'No reason given'}`;
                    break;
                case 'score_updated':
                    message = `Score update: ${event.score} points`;
                    break;
                case 'round_toggled':
                    message = `Round ${event.roundId} ${event.open ? 'opened' : 'closed'}`;
                    checkGameAvailability(); // Re-check availability
                    break;
                case 'game_toggled':
                    message = `Game ${event.gameId} ${event.open ? 'opened' : 'closed'}`;
                    checkGameAvailability(); // Re-check availability
                    break;
                case 'session_started':
                    message = 'Session started - cities generated';
                    break;
                case 'cities_approved':
                    message = 'Cities approved - game is now active';
                    checkGameAvailability();
                    break;
                case 'session_ended':
                    message = `Session ended: ${event.reason || 'No reason given'}`;
                    break;
            }
            
            if (message) {
                showNotification(message);
            }
        }

        function updateLiveSessionInfo() {
            if (!sessionData) return;
            
            DOM.sessionInfo.innerHTML = `
                <h3>Session: ${sessionData.joinCode}</h3>
                <p><strong>Player:</strong> ${playerName}</p>
                <p><strong>Game Type:</strong> ${sessionData.gameType}</p>
                <p><strong>Status:</strong> ${sessionData.status}</p>
            `;
            
            DOM.liveStatus.textContent = sessionData.status;
            DOM.livePlayersCount.textContent = sessionData.players ? sessionData.players.length : 0;
            DOM.liveConnections.textContent = sessionData.connectionCount || 0;
        }

        function updateLivePlayersList() {
            if (!sessionData || !sessionData.players) return;
            
            let html = '';
            sessionData.players.forEach(player => {
                const isCurrentPlayer = player.id === playerId;
                let statusClass = player.status === 'active' ? '' : player.status;
                if (isCurrentPlayer) statusClass += ' you';
                
                html += `<div class="player-item ${statusClass}">
                    <div>
                        <strong>${player.name}</strong>${isCurrentPlayer ? ' (You)' : ''} - ${player.status}
                        ${player.note ? ` - <em>${player.note}</em>` : ''}
                    </div>
                    <div>${player.score || 0} pts</div>
                </div>`;
            });
            
            DOM.playersListElement.innerHTML = html || '<p>No players yet</p>';
        }

        function updateLiveLeaderboard() {
            if (!sessionData || !sessionData.scores) {
                DOM.leaderboardContent.innerHTML = '<p>Waiting for scores...</p>';
                return;
            }
            
            let html = '<table><tr><th>Rank</th><th>Player</th><th>Score</th><th>Status</th></tr>';
            sessionData.scores.forEach((score, index) => {
                const isCurrentPlayer = score.playerId === playerId;
                const rowClass = isCurrentPlayer ? 'current-player' : '';
                html += `<tr class="${rowClass}">
                    <td>${index + 1}</td>
                    <td>${score.playerName}${isCurrentPlayer ? ' (You)' : ''}</td>
                    <td>${score.score}</td>
                    <td>${score.status}</td>
                </tr>`;
            });
            html += '</table>';
            
            DOM.leaderboardContent.innerHTML = html;
        }

        function checkGameAvailability() {
            if (!sessionData) return;
            
            if (sessionData.status === 'active') {
                // Check if any round is open
                const hasOpenRound = sessionData.rounds && sessionData.rounds.some(round => round.open);
                if (hasOpenRound) {
                    DOM.startButton.style.display = 'block';
                    showMessage('wait-message', 'Game is active! You can start playing.', 'success');
                } else {
                    DOM.startButton.style.display = 'none';
                    showMessage('wait-message', 'Game is active but no rounds are currently open. Waiting for administrator...', 'waiting');
                }
            } else if (sessionData.status === 'ended') {
                showMessage('wait-message', 'Game has ended. Thank you for playing!', 'info');
                DOM.startButton.style.display = 'none';
            } else {
                DOM.startButton.style.display = 'none';
                showMessage('wait-message', `Game status: ${sessionData.status}. Waiting for game to start...`, 'waiting');
            }
        }

        // --- Connection Status Management ---
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const textElement = document.getElementById('statusText');
            
            statusElement.className = 'connection-status';
            
            switch (status) {
                case 'connected':
                    statusElement.classList.add('status-connected');
                    textElement.innerHTML = '<span class="live-indicator" style="background: #28a745;"></span>Live';
                    break;
                case 'connecting':
                    statusElement.classList.add('status-connecting');
                    textElement.innerHTML = '<span class="live-indicator" style="background: #ffc107;"></span>Connecting...';
                    break;
                case 'disconnected':
                    statusElement.classList.add('status-disconnected');
                    textElement.innerHTML = 'üî¥ Disconnected';
                    break;
            }
        }
        
        function showNotification(message, type = 'info') {
            if (!message) return;
            
            const notification = document.getElementById('notification');
            notification.textContent = message;
            
            // Update styles based on type
            notification.className = 'notification';
            if (type === 'error') {
                notification.style.background = '#f8d7da';
                notification.style.borderColor = '#f5c6cb';
                notification.style.color = '#721c24';
            } else if (type === 'success') {
                notification.style.background = '#d4edda';
                notification.style.borderColor = '#c3e6cb';
                notification.style.color = '#155724';
            } else {
                notification.style.background = '#d1ecf1';
                notification.style.borderColor = '#bee5eb';
                notification.style.color = '#0c5460';
            }
            
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 4000);
        }

        // --- Session Management ---
        function joinSession() {
            const code = document.getElementById('session-code').value.trim().toUpperCase();
            const name = document.getElementById('player-name').value.trim();
            
            if (!code || !name) {
                showMessage('join-message', 'Please enter both session code and your name.', 'error');
                return;
            }
            
            sessionCode = code;
            playerName = name;
            playerId = generatePlayerId();
            
            DOM.joinButton.disabled = true;
            DOM.joinButton.textContent = 'Connecting...';
            
            try {
                // Connect to WebSocket
                gameWebSocket = new GameWebSocket(sessionCode);
                
                // Send join player message after connection
                setTimeout(() => {
                    if (gameWebSocket?.ws?.readyState === WebSocket.OPEN) {
                        gameWebSocket.send({
                            type: 'join_player',
                            playerId: playerId,
                            playerName: playerName
                        });
                        
                        showSessionWaiting();
                    } else {
                        showMessage('join-message', 'Failed to connect to session. Please try again.', 'error');
                        DOM.joinButton.disabled = false;
                        DOM.joinButton.textContent = 'Join Live Session';
                    }
                }, 1000);
                
            } catch (error) {
                showMessage('join-message', `Failed to join session: ${error.message}`, 'error');
                DOM.joinButton.disabled = false;
                DOM.joinButton.textContent = 'Join Live Session';
            }
        }

        function showSessionWaiting() {
            DOM.sessionJoin.style.display = 'none';
            DOM.sessionWaiting.style.display = 'block';
        }

        function resetToJoinScreen() {
            if (gameWebSocket) {
                gameWebSocket.close();
                gameWebSocket = null;
            }
            
            sessionCode = null;
            playerName = null;
            playerId = null;
            sessionData = null;
            gameInProgress = false;
            
            DOM.gameContainer.style.display = 'none';
            DOM.sessionWaiting.style.display = 'none';
            DOM.sessionJoin.style.display = 'block';
            DOM.joinButton.disabled = false;
            DOM.joinButton.textContent = 'Join Live Session';
            
            updateConnectionStatus('disconnected');
        }

        // --- Game Functions ---
        function startGame() {
            if (!sessionData || sessionData.status !== 'active') {
                showNotification('Game is not active yet. Please wait.', 'error');
                return;
            }
            
            // Find the first open round and game
            const openRound = sessionData.rounds.find(round => round.open);
            if (!openRound) {
                showNotification('No rounds are currently open. Please wait for administrator.', 'error');
                return;
            }
            
            const openGame = openRound.games.find(game => game.open);
            if (!openGame) {
                showNotification('No games are currently open in this round. Please wait for administrator.', 'error');
                return;
            }
            
            currentRound = openRound.id;
            currentGame = openGame.id;
            gameInProgress = true;
            
            // Switch to game view
            DOM.sessionWaiting.style.display = 'none';
            DOM.gameContainer.style.display = 'block';
            
            // Initialize maps
            initializeMaps().then(() => {
                loadGameLocation();
            });
        }

        async function loadGameLocation() {
            try {
                DOM.locationText.textContent = 'Loading location...';
                
                // Get city for current round/game using REST API
                const response = await fetch(`${API_BASE_URL}/api/cities?round=${currentRound}&game=${currentGame}`, {
                    headers: { 'X-Session-Code': sessionCode }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const cityData = await response.json();
                const cityName = cityData.city;
                
                DOM.locationText.textContent = `Finding a spot in ${cityName}...`;
                
                // Geocode the city using our proxy
                const geocodingResponse = await fetch(`${API_BASE_URL}/api/geocode?city=${encodeURIComponent(cityName)}`, {
                    headers: { 'X-Session-Code': sessionCode }
                });
                
                const geocodingData = await geocodingResponse.json();
                
                if (!geocodingData.features || geocodingData.features.length === 0) {
                    throw new Error(`Could not find location for ${cityName}`);
                }
                
                const feature = geocodingData.features[0];
                const bounds = feature.bbox;
                const center = feature.center;
                
                let randomLngLatArray;
                if (bounds) {
                    randomLngLatArray = getRandomCoordinateInBounds(bounds);
                } else if (center) {
                    randomLngLatArray = [center[0] + (Math.random() - 0.5) * 0.02, center[1] + (Math.random() - 0.5) * 0.02];
                } else {
                    throw new Error(`No location data for ${cityName}`);
                }
                
                if (mainMap) {
                    mainMap.jumpTo({ center: randomLngLatArray, zoom: INITIAL_ZOOM_LEVEL, essential: true });
                }
                
                DOM.locationText.textContent = `Location: ${feature.place_name || cityName}`;
                addOrUpdateSdkMarker(randomLngLatArray);
                updateGameStatus();
                
            } catch (error) {
                DOM.locationText.textContent = `Error loading location: ${error.message}`;
                console.error('Location loading error:', error);
            }
        }

        function updateGameStatus() {
            DOM.roundCountText.textContent = `Round: ${currentRound} | Game: ${currentGame}`;
            DOM.gameStatus.innerHTML = `
                <div class="status-item">
                    <span class="status-value">Round ${currentRound}</span>
                    <span>Current Round</span>
                </div>
                <div class="status-item">
                    <span class="status-value">Game ${currentGame}</span>
                    <span>Current Game</span>
                </div>
                <div class="status-item">
                    <span class="status-value">${totalScore}</span>
                    <span>Your Score</span>
                </div>
                <div class="status-item">
                    <span class="status-value">${sessionCode}</span>
                    <span>Session</span>
                </div>
            `;
        }

        async function submitGuess() {
            console.log("Submit button clicked.");
            const guess = convertToLngLat(userGuessLngLat);
            const actual = convertToLngLat(actualLocationCoords);

            if (!guess) {
                DOM.submitStatusText.textContent = 'Please make a guess by clicking on the overlay map.';
                return;
            }
            if (!actual) {
                DOM.submitStatusText.textContent = 'Error: No actual location set for scoring.';
                return;
            }

            const scoreResult = calculateGeoGuessrScore(actual.lat, actual.lng, guess.lat, guess.lng);
            
            if (isNaN(scoreResult.score) || isNaN(scoreResult.distance)) {
                DOM.submitStatusText.textContent = 'Error: Score calculation failed.';
                return;
            }

            totalScore += scoreResult.score;
            DOM.pointsScoreText.textContent = `Round Score: ${scoreResult.score} points (${(scoreResult.distance / 1000).toFixed(2)} km) | Total Score: ${totalScore} points`;
            DOM.submitStatusText.textContent = `Guess submitted! You were ${(scoreResult.distance / 1000).toFixed(2)} km away.`;

            if (currentSdkMarker && currentSdkMarker.getElement()) {
                currentSdkMarker.getElement().style.display = 'block';
            }
            
            setOverlayMapFullscreen(true, { guess: guess, actual: actual });
            placeRealLocationPin(actual);

            if (overlayMap.getLayer('line-layer')) {
                overlayMap.setLayoutProperty('line-layer', 'visibility', 'visible');
            }
            lineLayerVisible = true;
            updateLineBetweenPins();

            displayScoresPopup(scoreResult.score, totalScore);
            DOM.submitGuessBtn.disabled = true;

            // Post score via WebSocket
            if (gameWebSocket?.ws?.readyState === WebSocket.OPEN) {
                gameWebSocket.send({
                    type: 'post_score',
                    playerId: playerId,
                    score: scoreResult.score,
                    roundId: currentRound,
                    gameId: currentGame
                });
            } else {
                showNotification('Warning: Could not save score - connection lost', 'error');
            }

            // Show continue button or auto-continue based on game state
            setTimeout(() => {
                checkForNextGame();
            }, 3000);
        }

        function checkForNextGame() {
            if (!sessionData) return;
            
            const currentRoundData = sessionData.rounds.find(r => r.id === currentRound);
            if (!currentRoundData) {
                showWaitingForNextGame('Current round not found. Please wait for administrator instructions.');
                return;
            }
            
            // Look for next game in current round
            const nextGameInRound = currentRoundData.games.find(g => g.id > currentGame && g.open);
            
            if (nextGameInRound) {
                showContinueButton(() => proceedToNextGame(nextGameInRound.id, currentRound));
            } else {
                // Look for next round
                const nextRound = sessionData.rounds.find(r => r.id > currentRound && r.open);
                
                if (nextRound && nextRound.games.some(g => g.open)) {
                    const firstGameInRound = nextRound.games.find(g => g.open);
                    showContinueButton(() => proceedToNextGame(firstGameInRound.id, nextRound.id));
                } else {
                    showWaitingForNextGame('No more games are currently available. Waiting for administrator...');
                }
            }
        }

        function showContinueButton(callback) {
            DOM.submitStatusText.innerHTML = `
                Guess submitted! 
                <button onclick="continueToNext()" style="margin-left: 10px; padding: 8px 16px; background: #0cc0df; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Continue to Next Game
                </button>
            `;
            window.continueToNext = callback;
        }

        function showWaitingForNextGame(message) {
            DOM.submitStatusText.textContent = message;
        }

        function proceedToNextGame(gameId, roundId) {
            currentGame = gameId;
            currentRound = roundId;
            resetGameUI();
            loadGameLocation();
        }

        function resetGameUI() {
            DOM.locationText.textContent = 'Loading new location...';
            DOM.guessedCoordsText.textContent = 'Make your guess on the overlay map...';
            DOM.submitStatusText.textContent = 'Place your guess on the overlay map...';
            hideScoresPopup();

            if (currentSdkMarker) {
                currentSdkMarker.remove();
                currentSdkMarker = null;
            }
            if (guessPinElement) {
                guessPinElement.remove();
                guessPinElement = null;
            }
            userGuessLngLat = null;
            overlayMap.off('move', updateGuessPinPositionHandler);

            if (realLocationPinElement) {
                realLocationPinElement.remove();
                realLocationPinElement = null;
            }
            overlayMap.off('move', updateRealLocationPinPositionHandler);
            
            actualLocationCoords = null;

            if (overlayMap && overlayMap.getLayer('line-layer')) {
                overlayMap.setLayoutProperty('line-layer', 'visibility', 'none');
            }
            lineLayerVisible = false;

            setOverlayMapFullscreen(false);
            DOM.submitGuessBtn.disabled = false;
        }

        // --- Utility Functions ---
        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            const className = type === 'error' ? 'error-message' : 
                             type === 'success' ? 'success-message' : 
                             type === 'waiting' ? 'waiting-message' : 
                             'session-info';
            element.innerHTML = `<div class="${className}">${message}</div>`;
        }

        function getRandomCoordinateInBounds(bounds) {
            const [minLng, minLat, maxLng, maxLat] = bounds;
            const buffer = 0.001;
            const bufferedMinLng = minLng + (maxLng - minLng) * buffer;
            const bufferedMinLat = minLat + (maxLat - minLat) * buffer;
            const bufferedMaxLng = maxLng - (maxLng - minLng) * buffer;
            const bufferedMaxLat = maxLat - (maxLat - minLat) * buffer;
            const randomLng = bufferedMinLng + (bufferedMaxLng - bufferedMinLng) * Math.random();
            const randomLat = bufferedMinLat + (bufferedMaxLat - bufferedMinLat) * buffer;
            return [randomLng, randomLat];
        }

        function calculateDistanceInMeters(lat1, lon1, lat2, lon2) {
            if ([lat1, lon1, lat2, lon2].some(coord => typeof coord !== 'number')) {
                console.error("Invalid input types for calculateDistanceInMeters:", lat1, lon1, lat2, lon2);
                return NaN;
            }
            const R = 6371e3;
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(Math.max(0, a)), Math.sqrt(Math.max(0, 1 - a)));
            return R * c;
        }

        function calculateGeoGuessrScore(lat1, lon1, lat2, lon2) {
            const distance = calculateDistanceInMeters(lat1, lon1, lat2, lon2);
            if (isNaN(distance)) {
                console.error("Distance calculation returned NaN.");
                return { distance: NaN, score: NaN };
            }
            let score;
            if (distance <= PERFECT_SCORE_THRESHOLD_METERS) {
                score = MAX_SCORE_PER_ROUND;
            } else {
                score = MAX_SCORE_PER_ROUND * Math.exp(-distance / SCORE_DECAY_FACTOR);
                score = Math.max(0, Math.round(score));
            }
            return { distance, score };
        }

        function convertToLngLat(lngLatInput) {
            if (lngLatInput instanceof maptilersdk.LngLat) {
                return lngLatInput;
            }
            if (Array.isArray(lngLatInput) && lngLatInput.length === 2 &&
                typeof lngLatInput[0] === 'number' && typeof lngLatInput[1] === 'number') {
                return new maptilersdk.LngLat(lngLatInput[0], lngLatInput[1]);
            }
            console.error("convertToLngLat received invalid LngLat data:", lngLatInput);
            return null;
        }

        // --- Pin Management ---
        function createPinElement(className) {
            const element = document.createElement('div');
            element.className = className;
            return element;
        }

        function updatePinPosition(mapInstance, pinEl, lngLat) {
            if (!mapInstance || !pinEl || !lngLat) return;
            const validLngLat = convertToLngLat(lngLat);
            if (!validLngLat) {
                 console.error("Invalid LngLat object for pin positioning:", lngLat);
                 return;
            }
            const pixelCoords = mapInstance.project(validLngLat);
            pinEl.style.left = `${pixelCoords.x}px`;
            pinEl.style.top = `${pixelCoords.y}px`;
            pinEl.style.display = 'block';
        }

        function placeGuessPin(lngLat) {
            console.log('Attempting to place custom guess pin at LngLat:', lngLat);
            userGuessLngLat = convertToLngLat(lngLat);
            if (!userGuessLngLat) return;

            if (guessPinElement) guessPinElement.remove();
            guessPinElement = createPinElement('guess-pin');
            overlayMap.getCanvasContainer().appendChild(guessPinElement);
            updatePinPosition(overlayMap, guessPinElement, userGuessLngLat);

            DOM.guessedCoordsText.textContent = `Guessed Location: Lng: ${userGuessLngLat.lng.toFixed(6)}, Lat: ${userGuessLngLat.lat.toFixed(6)}`;
            DOM.submitStatusText.textContent = 'Guess placed. Click Submit!';

            overlayMap.off('move', updateGuessPinPositionHandler);
            overlayMap.on('move', updateGuessPinPositionHandler);
            console.log("Guess pin placed. userGuessLngLat:", userGuessLngLat);
        }
        
        const updateGuessPinPositionHandler = () => updatePinPosition(overlayMap, guessPinElement, userGuessLngLat);
        
        function placeRealLocationPin(lngLat) {
            console.log('Attempting to place custom real location pin at LngLat:', lngLat);
            const validLngLat = convertToLngLat(lngLat);
            if(!validLngLat) return;
            if (realLocationPinElement) realLocationPinElement.remove();
            realLocationPinElement = createPinElement('real-location-pin');
            overlayMap.getCanvasContainer().appendChild(realLocationPinElement);
            updatePinPosition(overlayMap, realLocationPinElement, validLngLat);

            overlayMap.off('move', updateRealLocationPinPositionHandler);
            overlayMap.on('move', updateRealLocationPinPositionHandler);
            console.log("Real location pin placed. actualLocationCoords:", actualLocationCoords);
        }
        
        const updateRealLocationPinPositionHandler = () => updatePinPosition(overlayMap, realLocationPinElement, actualLocationCoords);

        // --- Map Interaction & UI Updates ---
        function updateLineBetweenPins() {
            if (!lineLayerVisible || !overlayMap || !userGuessLngLat || !actualLocationCoords) return;

            const validUserGuess = convertToLngLat(userGuessLngLat);
            const validActualLocation = convertToLngLat(actualLocationCoords);

            if (!validUserGuess || !validActualLocation) {
                console.error("Invalid LngLat objects for drawing line:", userGuessLngLat, actualLocationCoords);
                return;
            }

            const lineGeoJSON = {
                'type': 'Feature',
                'geometry': {
                    'type': 'LineString',
                    'coordinates': [
                        [validUserGuess.lng, validUserGuess.lat],
                        [validActualLocation.lng, validActualLocation.lat]
                    ]
                }
            };
            const source = overlayMap.getSource('line-source');
            if (source) {
                source.setData(lineGeoJSON);
            }
        }

        function displayScoresPopup(roundScore, currentTotalScore) {
            DOM.roundScoreDisplay.textContent = `Round Score: ${roundScore} points`;
            DOM.totalScoreDisplay.textContent = `Total Score: ${currentTotalScore} points`;
            DOM.roundScoreDisplay.style.display = 'block';
            DOM.totalScoreDisplay.style.display = 'block';
        }

        function hideScoresPopup() {
            DOM.roundScoreDisplay.style.display = 'none';
            DOM.totalScoreDisplay.style.display = 'none';
        }

        function setOverlayMapFullscreen(isFullscreen, fitBoundsLocations = null) {
            if (isFullscreen) {
                DOM.overlayMapElement.classList.add('overlay-map-fullscreen');
                overlayMap.resize();
                if (fitBoundsLocations && fitBoundsLocations.guess && fitBoundsLocations.actual) {
                    const bounds = new maptilersdk.LngLatBounds();
                    bounds.extend(fitBoundsLocations.guess);
                    bounds.extend(fitBoundsLocations.actual);
                    setTimeout(() => {
                        overlayMap.fitBounds(bounds, { padding: 50, duration: 1000, essential: true });
                    }, 300);
                }
            } else {
                DOM.overlayMapElement.classList.remove('overlay-map-fullscreen');
                overlayMap.flyTo({ center: OVERLAY_INITIAL_CENTER, zoom: OVERLAY_INITIAL_ZOOM, essential: true, duration: 0 });
                setTimeout(() => overlayMap.resize(), 450);
            }
        }

        function addOrUpdateSdkMarker(lngLatArray) {
            const lngLatObject = convertToLngLat(lngLatArray);
            if (!lngLatObject) {
                console.error("addOrUpdateSdkMarker received invalid LngLat data:", lngLatArray);
                return;
            }

            if (currentSdkMarker) currentSdkMarker.remove();
            currentSdkMarker = new maptilersdk.Marker().setLngLat(lngLatObject).addTo(mainMap);
            actualLocationCoords = lngLatObject;

            if (currentSdkMarker && currentSdkMarker.getElement()) {
                currentSdkMarker.getElement().style.display = 'none';
            }
            console.log("actualLocationCoords set to LngLat object:", actualLocationCoords);
        }

        // --- Map Initialization ---
        async function initializeMaps() {
            try {
                // Get map styles using our proxy
                const mainMapStyleResponse = await fetch(`${API_BASE_URL}/api/mapstyle?style=0196cb69-f55f-71f8-9a8f-90fa083f0f67`, {
                    headers: { 'X-Session-Code': sessionCode }
                });
                const overlayMapStyleResponse = await fetch(`${API_BASE_URL}/api/mapstyle?style=0196cb7f-9914-7a9b-aed1-8bfa7b9a0705`, {
                    headers: { 'X-Session-Code': sessionCode }
                });

                const mainMapStyle = await mainMapStyleResponse.json();
                const overlayMapStyle = await overlayMapStyleResponse.json();

                // Set up MapTiler SDK with a dummy key (we're using proxied styles)
                maptilersdk.config.apiKey = 'dummy';

                mainMap = new maptilersdk.Map({
                    container: 'maptiler-map',
                    style: mainMapStyle,
                    center: [0, 0],
                    zoom: 1,
                    interactive: false
                });

                overlayMap = new maptilersdk.Map({
                    container: 'overlay-map',
                    style: overlayMapStyle,
                    center: OVERLAY_INITIAL_CENTER,
                    zoom: OVERLAY_INITIAL_ZOOM,
                    interactive: true
                });

                overlayMap.on('style.load', () => {
                    // Add line layer for showing distance
                    overlayMap.addSource('line-source', {
                        'type': 'geojson',
                        'data': { 'type': 'Feature', 'geometry': { 'type': 'LineString', 'coordinates': [] } }
                    });
                    overlayMap.addLayer({
                        'id': 'line-layer', 'type': 'line', 'source': 'line-source',
                        'layout': { 'line-join': 'round', 'line-cap': 'round', 'visibility': 'none' },
                        'paint': { 'line-color': '#000', 'line-width': 2, 'line-dasharray': [0.5, 2] }
                    });
                    overlayMap.on('move', updateLineBetweenPins);

                    // Add click handlers for placing guess pins
                    const placeGuessPinHandler = (e) => {
                        if (e.type === 'contextmenu') e.preventDefault();
                        if (!DOM.overlayMapElement.classList.contains('overlay-map-fullscreen')) {
                            placeGuessPin(e.lngLat);
                        }
                    };
                    overlayMap.on('click', placeGuessPinHandler);
                    overlayMap.on('contextmenu', placeGuessPinHandler);
                });

                // Handle overlay map transitions
                DOM.overlayMapElement.addEventListener('transitionend', () => {
                    if (overlayMap) {
                        overlayMap.resize();
                        if (guessPinElement && userGuessLngLat) updateGuessPinPositionHandler();
                        if (realLocationPinElement && actualLocationCoords) updateRealLocationPinPositionHandler();
                        updateLineBetweenPins();
                    }
                });

                // Add submit button handler
                DOM.submitGuessBtn.addEventListener('click', submitGuess);

                console.log('Maps initialized successfully');
                
            } catch (error) {
                console.error('Failed to initialize maps:', error);
                DOM.locationText.textContent = `Failed to load maps: ${error.message}`;
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements();
            updateConnectionStatus('disconnected');
        });

        // --- Cleanup on page unload ---
        window.addEventListener('beforeunload', () => {
            if (gameWebSocket) {
                gameWebSocket.close();
            }
        });
    </script>
</body>
</html>
