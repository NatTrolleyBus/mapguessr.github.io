<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
        }

        header {
            background-color: #0cc0df;
            padding: 20px;
            border-radius: 0 0 5px 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        h1 {
            color: #444;
            margin-top: 0;
            margin-right: 20px; /* Space between title and buttons */
        }
        .auth-section {
            display: flex;
            gap: 10px; /* Space between buttons/user info */
            align-items: center;
            flex-wrap: wrap;
        }
        .auth-section button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .auth-section #login-button {
            background-color: #4CAF50; /* Green */
            color: white;
        }
        .auth-section #register-button {
            background-color: #008CBA; /* Blue */
            color: white;
        }
        .user-info {
            color: #444;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .user-info #logout-button {
            background-color: #f44336; /* Red */
            color: white;
        }

        main {
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        section {
            margin-bottom: 30px;
        }
        /* Make maps-container relative to position its children absolutely */
        .maps-container {
            position: relative;
            height: 600px; /* Fixed height for the container */
            width: 100%;
            border: 1px solid #ccc;
            box-sizing: border-box; /* Include padding and border in the element's total width and height */
            margin-bottom: 20px;
        }
        .map-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        #guess-map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        #location-map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none; /* Hidden by default */
        }
        #game-info {
            background-color: #f2f2f2;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
        }
        #game-info p {
            margin: 5px 0;
            font-size: 1.1em;
            font-weight: bold;
        }
        .buttons-container {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .buttons-container button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #eee;
        }
        .buttons-container button:hover:enabled {
            background-color: #ddd;
        }
        .buttons-container button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        #result-screen {
            text-align: center;
            padding: 40px 20px;
            background-color: #e0f2f7;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #result-screen h2 {
            color: #2196F3;
            margin-bottom: 20px;
        }
        #result-screen p {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        #play-again-btn {
            background-color: #4CAF50;
            color: white;
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #play-again-btn:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <header>
        <h1>Map Guessr</h1>
        <div class="auth-section">
            <div id="auth-buttons">
                <button id="login-button">Login</button>
                <button id="register-button">Register</button>
            </div>
            <div id="user-display" class="user-info" style="display: none;">
                <span id="user-greeting"></span>
                <button id="logout-button">Logout</button>
            </div>
        </div>
    </header>
    <main>
        <section id="game-section">
            <div id="game-info">
                <p id="round-count">Round: 1</p>
                <p>Total Score: <span id="total-score">0</span></p>
            </div>

            <div class="maps-container">
                <div id="guess-map" class="map-wrapper"></div>
                <div id="location-map" class="map-wrapper"></div>
            </div>

            <div class="buttons-container">
                <button id="init-maps">Initialize Maps</button>
                <input type="text" id="api-token" placeholder="Enter Maptiler API Key" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc; width: 200px;">
                <button id="submit-guess" disabled>Submit Guess</button>
                <button id="new-location" disabled>New Location</button>
            </div>
        </section>

        <section id="result-screen" style="display: none;">
            <h2>Game Over!</h2>
            <p>Your Final Score: <span id="final-score">0</span></p>
            <p>Distance from correct location: <span id="distance-info"></span></p>
            <button id="play-again-btn">Play Again</button>
        </section>
    </main>

    <script>
        // --- Maptiler Global Variables and Initialization (Existing Code) ---
        let guessMap;
        let locationMap;
        let currentMarker; // To store the marker on the guess map
        let correctLocationMarker; // To store the marker on the location map
        let guessedLocationMarker; // To store the guessed location marker on the location map
        let geojson; // To store the GeoJSON for the correct location
        let lineGeojson; // To store the GeoJSON for the line between guess and correct location
        let currentCityCoords;
        let totalScore = 0;
        let roundCount = 1;
        const MAX_ROUNDS = 5; // You can change this to set the number of rounds

        const API_KEY_STORAGE_KEY = 'maptiler_api_key'; // Key for local storage

        document.addEventListener('DOMContentLoaded', () => {
            const initMapsBtn = document.getElementById('init-maps');
            const apiTokenInput = document.getElementById('api-token');
            const submitGuessBtn = document.getElementById('submit-guess');
            const newLocationBtn = document.getElementById('new-location');
            const playAgainBtn = document.getElementById('play-again-btn');
            const gameSection = document.getElementById('game-section');
            const resultScreen = document.getElementById('result-screen');
            const gameInfoSection = document.getElementById('game-info');

            // Load API key from local storage if available
            const storedApiKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (storedApiKey) {
                apiTokenInput.value = storedApiKey;
                // Automatically initialize maps if key is present on load
                initializeMaps(storedApiKey);
            }

            initMapsBtn.addEventListener('click', () => {
                const apiKey = apiTokenInput.value;
                if (apiKey) {
                    localStorage.setItem(API_KEY_STORAGE_KEY, apiKey); // Save API key
                    initializeMaps(apiKey);
                } else {
                    alert('Please enter a Maptiler API Key.');
                }
            });

            function initializeMaps(apiKey) {
                if (guessMap && locationMap) {
                    console.log("Maps already initialized.");
                    return;
                }
                maptilersdk.config.apiKey = apiKey;
                guessMap = new maptilersdk.Map({
                    container: 'guess-map', // container's id or the HTML element in which the map will be rendered
                    style: maptilersdk.MapStyle.STREETS,
                    center: [0, 0],
                    zoom: 1
                });

                locationMap = new maptilersdk.Map({
                    container: 'location-map',
                    style: maptilersdk.MapStyle.STREETS,
                    center: [0, 0],
                    zoom: 1
                });

                guessMap.on('load', () => {
                    findRandomCityAndSpot();
                    apiTokenInput.disabled = true;
                    initMapsBtn.disabled = true;
                    initMapsBtn.textContent = 'Maps Loaded';
                    submitGuessBtn.disabled = false;
                    newLocationBtn.disabled = false;
                });

                guessMap.on('click', (e) => {
                    if (currentMarker) {
                        currentMarker.setLngLat(e.lngLat);
                    } else {
                        currentMarker = new maptilersdk.Marker({ color: "#FF0000" })
                            .setLngLat(e.lngLat)
                            .addTo(guessMap);
                    }
                });
            }

            async function findRandomCityAndSpot() {
                try {
                    const response = await fetch('https://secure-api.maptiler.com/geocoding/random-city.json?country=US&limit=1&key=' + maptilersdk.config.apiKey);
                    const data = await response.json();
                    if (data && data.features && data.features.length > 0) {
                        const city = data.features[0];
                        currentCityCoords = city.center;
                        guessMap.setCenter([0, 0]);
                        guessMap.setZoom(1);
                        if (currentMarker) {
                            currentMarker.remove();
                            currentMarker = null;
                        }
                        locationMap.style.display = 'none';
                        document.getElementById('guess-map').style.display = 'block';
                        submitGuessBtn.disabled = false;
                        newLocationBtn.disabled = false;
                        if (correctLocationMarker) correctLocationMarker.remove();
                        if (guessedLocationMarker) guessedLocationMarker.remove();
                        if (guessMap.getSource('line')) guessMap.removeSource('line').removeLayer('line-layer');
                        if (locationMap.getSource('line')) locationMap.removeSource('line').removeLayer('line-layer');
                    } else {
                        console.error('Could not find a random city.');
                    }
                } catch (error) {
                    console.error('Error fetching random city:', error);
                    alert('Failed to load a new location. Please check your API key and network connection.');
                }
            }

            function calculateDistance(coords1, coords2) {
                const toRad = (x) => x * Math.PI / 180;
                const R = 6371; // Earth's radius in kilometers

                const dLat = toRad(coords2[1] - coords1[1]);
                const dLon = toRad(coords2[0] - coords1[0]);

                const a =
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(coords1[1])) * Math.cos(toRad(coords2[1])) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c; // Distance in km
            }

            function calculateScore(distance) {
                // Example scoring: Max score for very close, less for further away
                // This is a simple inverse relationship, you can make it more complex
                const maxDistance = 20000; // Max possible distance on Earth roughly
                const maxScore = 1000;

                if (distance < 1) return maxScore; // Very close, max score
                if (distance > maxDistance) return 0; // Too far, 0 score

                return Math.max(0, Math.round(maxScore * (1 - (distance / maxDistance))));
            }

            submitGuessBtn.addEventListener('click', () => {
                if (!currentMarker) {
                    alert('Please click on the guess map to place your guess!');
                    return;
                }

                const guessedCoords = currentMarker.getLngLat().toArray();
                const distance = calculateDistance(currentCityCoords, guessedCoords);
                const score = calculateScore(distance);
                totalScore += score;
                document.getElementById('total-score').textContent = totalScore;
                document.getElementById('distance-info').textContent =
                    `You were ${distance.toFixed(2)} km away. You scored ${score} points this round.`;

                // Show correct location and guessed location on locationMap
                document.getElementById('guess-map').style.display = 'none';
                locationMap.style.display = 'block';
                locationMap.setCenter(currentCityCoords);
                locationMap.setZoom(5);

                // Add markers and line to locationMap
                correctLocationMarker = new maptilersdk.Marker({ color: "#00FF00" }) // Green for correct
                    .setLngLat(currentCityCoords)
                    .addTo(locationMap);

                guessedLocationMarker = new maptilersdk.Marker({ color: "#FF0000" }) // Red for guessed
                    .setLngLat(guessedCoords)
                    .addTo(locationMap);

                // Draw line between guessed and correct
                lineGeojson = {
                    'type': 'FeatureCollection',
                    'features': [{
                        'type': 'Feature',
                        'geometry': {
                            'type': 'LineString',
                            'coordinates': [guessedCoords, currentCityCoords]
                        }
                    }]
                };

                if (locationMap.getSource('line')) {
                    locationMap.getSource('line').setData(lineGeojson);
                } else {
                    locationMap.addSource('line', {
                        'type': 'geojson',
                        'data': lineGeojson
                    });
                    locationMap.addLayer({
                        'id': 'line-layer',
                        'type': 'line',
                        'source': 'line',
                        'paint': {
                            'line-color': '#888',
                            'line-width': 4
                        }
                    });
                }

                roundCount++;
                if (roundCount > MAX_ROUNDS) {
                    gameSection.style.display = 'none';
                    resultScreen.style.display = 'block';
                    document.getElementById('final-score').textContent = totalScore;
                } else {
                    // Prepare for next round
                    submitGuessBtn.disabled = true;
                    newLocationBtn.disabled = true;
                    setTimeout(() => {
                        document.getElementById('round-count').textContent = `Round: ${roundCount}`;
                        findRandomCityAndSpot(); // Start the next round
                    }, 3000); // Wait 3 seconds before next round
                }
            });

            newLocationBtn.addEventListener('click', () => {
                roundCount++;
                if (roundCount > MAX_ROUNDS) {
                    gameSection.style.display = 'none';
                    resultScreen.style.display = 'block';
                    document.getElementById('final-score').textContent = totalScore;
                } else {
                    document.getElementById('round-count').textContent = `Round: ${roundCount}`;
                    findRandomCityAndSpot(); // Start the next round
                }

                submitGuessBtn.disabled = true;
                newLocationBtn.disabled = true;
            });

            playAgainBtn.addEventListener('click', () => {
                // Reset game state
                totalScore = 0;
                roundCount = 1;
                document.getElementById('round-count').textContent = `Round: ${roundCount}`;

                // Hide result screen and show game elements
                resultScreen.style.display = 'none';
                gameSection.style.display = 'block';
                gameInfoSection.style.display = 'block';
                document.getElementById('submit-guess').disabled = false;
                document.getElementById('new-location').disabled = false;
                document.getElementById('api-token').disabled = true; // Keep token input disabled
                document.getElementById('init-maps').disabled = true; // Keep init button disabled if maps already loaded
                document.getElementById('init-maps').textContent = 'Maps Loaded'; // Keep init button text

                // Start a new game
                findRandomCityAndSpot();
            });

            // --- OAuth 2.1 Implementation (New/Modified Code) ---

            const loginButton = document.getElementById('login-button');
            const registerButton = document.getElementById('register-button');
            const logoutButton = document.getElementById('logout-button');
            const authButtonsDiv = document.getElementById('auth-buttons');
            const userDisplayDiv = document.getElementById('user-display');
            const userGreetingSpan = document.getElementById('user-greeting');

            // IMPORTANT: Replace with your actual domain. This MUST be approved by transitspotter administrators.
            const YOUR_DOMAIN = 'mapguessr-github-io.pages.dev'; // e.g., 'mapguessr.com'
            const YOUR_REDIRECT_URI = `https://${YOUR_DOMAIN}/oauth/callback`; // e.g., 'https://mapguessr.com/oauth/callback'

            // --- Helper Functions for OAuth ---
            async function generateCodeVerifierAndChallenge() {
                const codeVerifier = generateRandomString(64);
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                const codeChallenge = btoa(String.fromCharCode(...new Uint8Array(digest)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
                return { codeVerifier, codeChallenge };
            }

            function generateRandomString(length) {
                const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
                let result = '';
                const randomValues = new Uint8Array(length);
                crypto.getRandomValues(randomValues);
                for (let i = 0; i < length; i++) {
                    result += charset[randomValues[i] % charset.length];
                }
                return result;
            }

            // --- Core OAuth Flow Functions ---

            // Initiates the OAuth login/registration process
            async function startOAuthFlow() {
                const { codeVerifier, codeChallenge } = await generateCodeVerifierAndChallenge();
                const state = generateRandomString(32);

                sessionStorage.setItem('code_verifier', codeVerifier);
                sessionStorage.setItem('oauth_state', state);

                const authUrl = new URL('https://auth.transitspotter.com/external/authorize');
                authUrl.searchParams.append('response_type', 'code');
                authUrl.searchParams.append('client_id', YOUR_DOMAIN);
                authUrl.searchParams.append('redirect_uri', YOUR_REDIRECT_URI);
                authUrl.searchParams.append('code_challenge', codeChallenge);
                authUrl.searchParams.append('code_challenge_method', 'S256');
                authUrl.searchParams.append('state', state);

                window.location.href = authUrl.toString();
            }

            // Handles the callback from the OAuth provider
            async function handleOAuthCallback() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');

                if (error) {
                    console.error('OAuth error:', error, urlParams.get('error_description'));
                    alert('Authentication failed: ' + (urlParams.get('error_description') || error));
                    window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                    updateAuthUI();
                    return;
                }

                const storedState = sessionStorage.getItem('oauth_state');
                if (!state || state !== storedState) {
                    console.error('Invalid state parameter');
                    alert('Authentication failed: Invalid state. Possible CSRF attack.');
                    window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                    updateAuthUI();
                    return;
                }

                const codeVerifier = sessionStorage.getItem('code_verifier');
                if (!codeVerifier) {
                    console.error('Code verifier not found');
                    alert('Authentication failed: Missing code verifier.');
                    window.history.replaceState({}, document.title, window.location.pathname); // Clean URL
                    updateAuthUI();
                    return;
                }

                try {
                    const response = await fetch('https://auth.transitspotter.com/external/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Origin': window.location.origin
                        },
                        body: JSON.stringify({
                            grant_type: 'authorization_code',
                            code: code,
                            client_id: YOUR_DOMAIN,
                            redirect_uri: YOUR_REDIRECT_URI,
                            code_verifier: codeVerifier
                        })
                    });

                    const tokenData = await response.json();

                    if (tokenData.error) {
                        console.error('Token error:', tokenData.error, tokenData.error_description);
                        alert('Token exchange failed: ' + (tokenData.error_description || tokenData.error));
                        updateAuthUI();
                        return;
                    }

                    localStorage.setItem('access_token', tokenData.access_token);
                    localStorage.setItem('refresh_token', tokenData.refresh_token);
                    localStorage.setItem('token_expiry', Date.now() + (tokenData.expires_in * 1000));

                    sessionStorage.removeItem('code_verifier');
                    sessionStorage.removeItem('oauth_state');

                    console.log('Authentication successful!');
                    await fetchAndDisplayUserInfo(); // Fetch and display user info after successful login
                } catch (error) {
                    console.error('Token exchange error:', error);
                    alert('An error occurred during token exchange.');
                } finally {
                    // Clean the URL after processing the callback to hide sensitive parameters
                    window.history.replaceState({}, document.title, window.location.pathname);
                    updateAuthUI(); // Update UI regardless of success or failure after handling callback
                }
            }

            // Fetches user information using the access token
            async function fetchAndDisplayUserInfo() {
                if (!localStorage.getItem('access_token')) {
                    updateAuthUI(); // Ensure UI is correct if no token
                    return;
                }

                if (!await ensureValidToken()) {
                    console.log('Could not ensure valid token, redirecting to login.');
                    return; // ensureValidToken already handles logout/redirect
                }

                const accessToken = localStorage.getItem('access_token');
                try {
                    const response = await fetch('https://auth.transitspotter.com/external/introspect', {
                        method: 'POST', // Introspect is POST
                        headers: {
                            'Content-Type': 'application/json',
                            'Origin': window.location.origin // Match the origin of your application
                        },
                        body: JSON.stringify({
                            token: accessToken,
                            token_type_hint: 'access_token'
                        })
                    });

                    const userInfo = await response.json();

                    if (userInfo.active && userInfo.sub) {
                        userGreetingSpan.textContent = `Hi, ${userInfo.sub}`;
                        updateAuthUI(true); // Show user info, hide login/register
                    } else {
                        console.error('User info not active or sub not found:', userInfo);
                        alert('Could not retrieve user information. Please log in again.');
                        logout(); // Log out if token is inactive or user info is incomplete
                    }
                } catch (error) {
                    console.error('Error fetching user info:', error);
                    alert('Failed to fetch user information.');
                    logout(); // Log out on error
                }
            }

            // Refreshes the access token using the refresh token
            async function refreshToken() {
                const refreshTokenValue = localStorage.getItem('refresh_token');
                if (!refreshTokenValue) {
                    console.warn('No refresh token available.');
                    return false;
                }

                try {
                    const response = await fetch('https://auth.transitspotter.com/external/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Origin': window.location.origin
                        },
                        body: JSON.stringify({
                            grant_type: 'refresh_token',
                            refresh_token: refreshTokenValue,
                            client_id: YOUR_DOMAIN
                        })
                    });

                    const tokenData = await response.json();

                    if (tokenData.error) {
                        console.error('Refresh token error:', tokenData.error, tokenData.error_description);
                        // If refresh fails, the refresh token might be expired or revoked.
                        // Force logout.
                        logout();
                        return false;
                    }

                    // Update stored tokens
                    localStorage.setItem('access_token', tokenData.access_token);
                    localStorage.setItem('refresh_token', tokenData.refresh_token); // New refresh token (token rotation)
                    localStorage.setItem('token_expiry', Date.now() + (tokenData.expires_in * 1000));
                    console.log('Tokens refreshed successfully.');
                    return true;
                } catch (error) {
                    console.error('Token refresh network error:', error);
                    logout(); // Log out on network errors during refresh
                    return false;
                }
            }

            // Ensures a valid token exists, refreshing if necessary
            async function ensureValidToken() {
                const accessToken = localStorage.getItem('access_token');
                const expiryTime = parseInt(localStorage.getItem('token_expiry'), 10);

                if (!accessToken) {
                    console.log('No access token found.');
                    return false;
                }

                // Refresh if token is expired or will expire in the next 5 minutes (300 seconds)
                if (Date.now() > expiryTime - 300000) {
                    console.log('Access token near expiry or expired. Attempting refresh...');
                    return await refreshToken();
                }

                return true; // Token is still valid
            }

            // Revokes tokens and clears local storage, then updates UI
            async function logout() {
                const accessToken = localStorage.getItem('access_token');
                const refreshTokenValue = localStorage.getItem('refresh_token');

                try {
                    // Revoke access token
                    if (accessToken) {
                        await fetch('https://auth.transitspotter.com/external/revoke', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Origin': window.location.origin
                            },
                            body: JSON.stringify({
                                token: accessToken,
                                token_type_hint: 'access_token'
                            })
                        });
                    }

                    // Revoke refresh token
                    if (refreshTokenValue) {
                        await fetch('https://auth.transitspotter.com/external/revoke', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Origin': window.location.origin
                            },
                            body: JSON.stringify({
                                token: refreshTokenValue,
                                token_type_hint: 'refresh_token'
                            })
                        });
                    }
                } catch (error) {
                    console.error('Error revoking tokens:', error);
                    // Continue with clearing local storage even if revoke fails
                } finally {
                    localStorage.removeItem('access_token');
                    localStorage.removeItem('refresh_token');
                    localStorage.removeItem('token_expiry');
                    console.log('Logged out successfully.');
                    updateAuthUI(); // Update UI to show login/register buttons
                    // Optionally redirect to home or login page
                    // window.location.href = '/';
                }
            }

            // --- UI Update Function ---
            function updateAuthUI(isLoggedIn = false) {
                if (isLoggedIn) {
                    authButtonsDiv.style.display = 'none';
                    userDisplayDiv.style.display = 'flex';
                } else {
                    authButtonsDiv.style.display = 'flex';
                    userDisplayDiv.style.display = 'none';
                    userGreetingSpan.textContent = ''; // Clear username
                }
            }

            // --- Event Listeners and Initial Checks ---
            if (loginButton) {
                loginButton.addEventListener('click', startOAuthFlow);
            }
            if (registerButton) {
                // For simplicity, register also uses the same OAuth flow.
                // The transitspotter auth page will handle new registrations.
                registerButton.addEventListener('click', startOAuthFlow);
            }
            if (logoutButton) {
                logoutButton.addEventListener('click', logout);
            }

            // Check if we are on the OAuth callback page or if a token already exists
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('code') || urlParams.has('error')) {
                // This means the user was redirected back from the OAuth provider
                handleOAuthCallback();
            } else {
                // On initial page load, check if already authenticated and display user info
                fetchAndDisplayUserInfo();
            }

            // Set up a periodic check to refresh tokens in the background (e.g., every 10 minutes)
            // This is an alternative to calling ensureValidToken before every API call.
            // Adjust interval as needed based on your token expiry and application needs.
            setInterval(async () => {
                if (localStorage.getItem('refresh_token')) { // Only try to refresh if a refresh token exists
                    console.log('Attempting periodic token refresh...');
                    await ensureValidToken();
                }
            }, 10 * 60 * 1000); // Every 10 minutes

            // Initial UI update call to ensure correct state on page load
            updateAuthUI(localStorage.getItem('access_token') !== null);

            // --- End of OAuth 2.1 Implementation ---
        });
    </script>
</body>
</html>
