<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr - Live Session Game</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #2c3e50;
            background-color: #f4f7f6;
        }
        header {
            background-color: #3498db;
            color: white;
            padding: 25px 20px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        h1 {
            margin-top: 0;
            font-size: 2.2em;
            letter-spacing: 1px;
        }
        p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        main {
            padding: 30px;
            max-width: 1200px;
            margin: 20px auto;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }
        section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #fdfdfd;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        
        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 13px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 7px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
        }
        .status-connected { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-connecting { background: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
        .status-disconnected { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .live-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            padding: 12px 20px;
            background: #e7f5fe;
            border: 1px solid #b3e0ff;
            border-radius: 5px;
            color: #0056b3;
            font-size: 15px;
            z-index: 1000;
            max-width: 350px;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Session Management Styles */
        .session-container {
            max-width: 500px;
            margin: 50px auto;
            padding: 35px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background-color: #fdfdfd;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.05);
        }
        .session-form {
            margin: 25px 0;
        }
        .session-form input {
            padding: 12px 15px;
            margin: 10px 0;
            font-size: 1.1em;
            border: 1px solid #ccc;
            border-radius: 6px;
            width: calc(100% - 30px);
            max-width: 280px;
            box-sizing: border-box;
        }
        .session-form button {
            padding: 14px 35px;
            font-size: 1.1em;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .session-form button:hover {
            background-color: #218838;
            transform: translateY(-2px);
        }
        .session-form button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: none;
        }
        .session-info {
            background-color: #e8f4f8;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #cce7f4;
        }
        .waiting-message, .error-message, .success-message {
            padding: 18px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 1.05em;
            border: 1px solid;
        }
        .waiting-message { background-color: #fff3cd; color: #856404; border-color: #ffeeba; }
        .error-message { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }
        .success-message { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        
        /* Live Player List */
        .live-players {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 25px 0;
            text-align: left;
            border: 1px solid #e9ecef;
        }
        .players-list-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: white;
            border-radius: 5px;
            border-left: 5px solid;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            font-size: 0.95em;
        }
        .player-item.you { border-left-color: #007bff; background-color: #eaf6ff; }
        .player-item.left { border-left-color: #ffc107; background-color: #fffde0; }
        .player-item.kicked { border-left-color: #dc3545; background-color: #ffe6e8; }
        .player-name {
            font-weight: bold;
        }
        .player-score {
            font-weight: 600;
            color: #3498db;
        }
        
        /* Game Styles */
        .game-container {
            display: none;
        }
        .maps-container {
            position: relative;
            height: 600px; /* Adjusted height for better fit */
            width: 100%;
            margin-bottom: 30px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        #maptiler-map {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            overflow: hidden;
            background-color: #eaeaea;
        }
        #overlay-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 350px; /* Slightly smaller for cleaner look */
            height: 250px; /* Slightly smaller for cleaner look */
            border: 2px solid #555;
            border-radius: 8px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.25);
            z-index: 10;
            transition: all 0.4s ease-in-out;
        }
        #overlay-map:hover:not(.overlay-map-fullscreen) {
            transform: scale(1.02); /* Subtle hover effect */
        }
        .overlay-map-fullscreen {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 100 !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }
        .submit-container {
            text-align: center;
            margin-bottom: 40px;
        }
        .submit-btn, .new-location-btn, .start-game-btn, .next-round-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 14px 30px;
            font-size: 1.1em;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin: 0 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .submit-btn:hover, .new-location-btn:hover, .start-game-btn:hover, .next-round-btn:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        .submit-btn:disabled, .new-location-btn:disabled, .start-game-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: translateY(0);
            box-shadow: none;
        }
        
        /* Live Leaderboard Styles */
        .leaderboard {
            background-color: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 25px 0;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .leaderboard table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .leaderboard th, .leaderboard td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        .leaderboard th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }
        .leaderboard tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .leaderboard tr.current-player {
            background-color: #e0f2f7 !important; /* Lighter shade of blue for current player */
            font-weight: bold;
            color: #2c3e50;
        }
        .leaderboard td:last-child, .leaderboard th:last-child {
            text-align: right;
        }
        
        footer {
            background-color: #3498db;
            color: white;
            padding: 15px;
            text-align: center;
            border-radius: 8px 8px 0 0;
            font-size: 0.9em;
            margin-top: 50px;
            box-shadow: 0 -3px 8px rgba(0,0,0,0.1);
        }
        .maptiler-ctrl-group,
        .maptiler-ctrl,
        .maplibregl-ctrl-group,
        .maplibregl-ctrl {
            display: none !important;
        }
        .guess-pin, .real-location-pin {
            position: absolute;
            width: 30px; /* Slightly larger pins */
            height: 45px;
            background-size: contain;
            background-repeat: no-repeat;
            transform: translate3d(-50%, -100%, 0);
            pointer-events: none;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3)); /* Add subtle shadow to pins */
        }
        .guess-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%23e74c3c" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            z-index: 101;
        }
        .real-location-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%2327ae60" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            z-index: 102;
        }
        #next-round-btn {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 14px 35px;
            font-size: 1.2em;
            background-color: #f39c12; /* A more prominent color for next round */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            z-index: 110;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        #next-round-btn:hover {
            background-color: #e67e22;
            transform: translateY(-2px);
        }
        
        /* Game Status Bar */
        .game-status-bar {
            background-color: #eaf6ff;
            padding: 18px;
            border-radius: 8px;
            margin: 25px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            border: 1px solid #cce7f4;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 15px;
            color: #555;
        }
        .status-value {
            font-weight: bold;
            font-size: 1.5em;
            color: #3498db;
            margin-bottom: 5px;
        }
        
        ul.game-progress-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        ul.game-progress-list li {
            background-color: #f4f7f6;
            padding: 12px 15px;
            margin-bottom: 8px;
            border-left: 5px solid #3498db;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            font-size: 1.05em;
        }

    </style>
</head>
<body>
    <div id="connectionStatus" class="connection-status status-connecting">
        <span class="live-indicator"></span>
        <span id="statusText">Not Connected</span>
    </div>
    
    <div id="notification" class="notification"></div>
    
    <header>
        <h1>Map Guessr - Live Session Game</h1>
        <p>Real-time Connected Multiplayer Experience</p>
    </header>
    <main>
        <div id="session-join" class="session-container">
            <h2>Join Live Game Session</h2>
            <p>Enter your session code and player name to join the live game.</p>
            <div class="session-form">
                <input type="text" id="session-code" placeholder="Session Code" maxlength="10">
                <br>
                <input type="text" id="player-name" placeholder="Your Name" maxlength="30">
                <br>
                <button onclick="joinSession()" id="join-button">Join Live Session</button>
            </div>
            <div id="join-message"></div>
        </div>

        <div id="session-waiting" class="session-container" style="display: none;">
            <h2>🔴 Live Session Joined!</h2>
            <div id="session-info" class="session-info"></div>
            
            <div class="live-players">
                <h4>👥 Live Players</h4>
                <div id="players-list" class="players-list-grid"></div>
            </div>
            
            <div class="waiting-message">
                <h3>⏳ Waiting for game to start...</h3>
                <p><strong>Live Status:</strong> Connected and waiting for administrator instructions</p>
                <p>You'll be automatically notified when the game becomes available!</p>
            </div>
            
            <div class="game-status-bar">
                <div class="status-item">
                    <span class="status-value" id="live-status">waiting</span>
                    <span>Status</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="live-players-count">0</span>
                    <span>Players</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="live-connections">0</span>
                    <span>Connected</span>
                </div>
            </div>
            
            <button class="start-game-btn" onclick="startGame()" id="start-button" style="display: none;">🎮 Start Playing</button>
            <div id="wait-message"></div>
        </div>

        <div id="game-container" class="game-container">
            <section>
                <h2>🎯 Live Game in Progress</h2>
                <div id="game-status" class="game-status-bar"></div>
                <div class="maps-container">
                    <div id="maptiler-map"></div>
                    <div id="overlay-map"></div>
                </div>
                <div class="submit-container">
                    <button class="submit-btn" id="submit-guess">Submit Guess</button>
                </div>
            </section>
            
            <section>
                <h2>📊 Game Progress</h2>
                <ul class="game-progress-list">
                    <li id="location-text">Waiting for location...</li>
                    <li id="guessed-coords">Make your guess on the overlay map...</li>
                    <li id="submit-status">Place your guess on the overlay map...</li>
                    <li id="points-score">Points: - | Total: 0 points</li>
                    <li id="round-count">Round: 1 | Game: 1</li>
                </ul>
            </section>

            <div id="leaderboard-container">
                <div class="leaderboard">
                    <h3>🏆 Live Leaderboard</h3>
                    <div id="leaderboard-content">
                        <p>Waiting for scores...</p>
                    </div>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <p>Live WebSocket-Based Map Guessr Game</p>
    </footer>

    <script>
        // --- Configuration ---
        const API_BASE_URL = 'https://game-session-worker.games-6cb.workers.dev';
        const API_KEY = ZS9RHHRim7f1OZRKuI6n; 
        maptilersdk.config.apiKey = API_KEY;
        const MAIN_MAP_STYLE_URL = `https://api.maptiler.com/maps/streets-v2/style.json?key=${API_KEY}`;
        const OVERLAY_MAP_STYLE_URL = `https://api.maptiler.com/maps/basic-v2/style.json?key=${API_KEY}`;
        const INITIAL_ZOOM_LEVEL = 15;
        const OVERLAY_INITIAL_CENTER = [0, 0];
        const OVERLAY_INITIAL_ZOOM = -0.5;
        const MAX_SCORE_PER_ROUND = 5000;
        const PERFECT_SCORE_THRESHOLD_METERS = 100;
        const SCORE_DECAY_FACTOR = 2000000;

        // --- Session State Variables ---
        let sessionCode = null;
        let playerName = null;
        let playerId = null;
        let sessionData = null;
        let currentRound = 1;
        let currentGame = 1;
        let gameWebSocket = null;
        
        // --- Game State Variables ---
        let mainMap = null;
        let overlayMap = null;
        let currentSdkMarker = null;
        let userGuessLngLat = null;
        let guessPinElement = null;
        let realLocationPinElement = null;
        let actualLocationCoords = null;
        let totalScore = 0;
        let lineLayerVisible = false;
        let gameInProgress = false;

        // --- DOM Element Cache ---
        const DOM = {};
        function cacheDOMElements() {
            DOM.sessionJoin = document.getElementById('session-join');
            DOM.sessionWaiting = document.getElementById('session-waiting');
            DOM.gameContainer = document.getElementById('game-container');
            DOM.sessionInfo = document.getElementById('session-info');
            DOM.waitMessage = document.getElementById('wait-message');
            DOM.joinMessage = document.getElementById('join-message');
            DOM.startButton = document.getElementById('start-button');
            DOM.locationText = document.getElementById('location-text');
            DOM.guessedCoordsText = document.getElementById('guessed-coords');
            DOM.submitStatusText = document.getElementById('submit-status');
            DOM.pointsScoreText = document.getElementById('points-score');
            DOM.roundCountText = document.getElementById('round-count');
            DOM.submitGuessBtn = document.getElementById('submit-guess');
            DOM.overlayMapElement = document.getElementById('overlay-map');
            DOM.mapsContainer = document.querySelector('.maps-container');
            DOM.leaderboardContainer = document.getElementById('leaderboard-container');
            DOM.leaderboardContent = document.getElementById('leaderboard-content');
            DOM.gameStatus = document.getElementById('game-status');
            DOM.playersListElement = document.getElementById('players-list');
            DOM.liveStatus = document.getElementById('live-status');
            DOM.livePlayersCount = document.getElementById('live-players-count');
            DOM.liveConnections = document.getElementById('live-connections');
            DOM.joinButton = document.getElementById('join-button');
            DOM.connectionStatus = document.getElementById('connectionStatus');
            DOM.statusText = document.getElementById('statusText');
            DOM.notification = document.getElementById('notification');
        }

        // --- Utility Functions ---
        function showNotification(message, type) {
            const notificationElement = DOM.notification;
            notificationElement.textContent = message;
            notificationElement.className = `notification ${type}`;
            notificationElement.style.display = 'block';
            setTimeout(() => {
                notificationElement.style.display = 'none';
            }, 5000);
        }

        function updateConnectionStatus(status) {
            const statusElement = DOM.connectionStatus;
            const statusTextElement = DOM.statusText;

            statusElement.className = `connection-status status-${status}`;
            switch (status) {
                case 'connected':
                    statusTextElement.textContent = 'Connected';
                    break;
                case 'connecting':
                    statusTextElement.textContent = 'Connecting...';
                    break;
                case 'disconnected':
                    statusTextElement.textContent = 'Disconnected';
                    break;
            }
        }

        function convertToLngLat(lngLatInput) {
            if (lngLatInput instanceof maptilersdk.LngLat) {
                return lngLatInput;
            }
            if (Array.isArray(lngLatInput) && lngLatInput.length === 2 && typeof lngLatInput[0] === 'number' && typeof lngLatInput[1] === 'number') {
                return new maptilersdk.LngLat(lngLatInput[0], lngLatInput[1]);
            }
            console.error('Invalid LngLat input:', lngLatInput);
            return null;
        }

        function getRandomCoordinateInBounds(bounds) {
            const [minLng, minLat, maxLng, maxLat] = bounds;
            const buffer = 0.001; // Small buffer to avoid extreme edges
            const bufferedMinLng = minLng + (maxLng - minLng) * buffer;
            const bufferedMinLat = minLat + (maxLat - minLat) * buffer;
            const bufferedMaxLng = maxLng - (maxLng - minLng) * buffer;
            const bufferedMaxLat = maxLat - (maxLat - minLat) * buffer;

            const randomLng = bufferedMinLng + (bufferedMaxLng - bufferedMinLng) * Math.random();
            const randomLat = bufferedMinLat + (bufferedMaxLat - bufferedMinLat) * Math.random();
            return [randomLng, randomLat];
        }

        function calculateDistanceInMeters(lat1, lon1, lat2, lon2) {
            if ([lat1, lon1, lat2, lon2].some(coord => typeof coord !== 'number')) {
                console.error("Invalid input types for calculateDistanceInMeters:", lat1, lon1, lat2, lon2);
                return NaN;
            }
            const R = 6371e3; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(Math.max(0, a)), Math.sqrt(Math.max(0, 1 - a)));
            return R * c;
        }

        function calculateGeoGuessrScore(lat1, lon1, lat2, lon2) {
            const distance = calculateDistanceInMeters(lat1, lon1, lat2, lon2);
            if (isNaN(distance)) {
                console.error("Distance calculation returned NaN.");
                return { distance: NaN, score: NaN };
            }

            let score;
            if (distance <= PERFECT_SCORE_THRESHOLD_METERS) {
                score = MAX_SCORE_PER_ROUND;
            } else {
                score = MAX_SCORE_PER_ROUND * Math.exp(-distance / SCORE_DECAY_FACTOR);
                score = Math.max(0, Math.round(score));
            }
            return { distance, score };
        }

        function addLineBetweenPins() {
            if (mainMap && userGuessLngLat && actualLocationCoords) {
                const lineGeoJSON = {
                    'type': 'FeatureCollection',
                    'features': [
                        {
                            'type': 'Feature',
                            'geometry': {
                                'type': 'LineString',
                                'properties': {},
                                'coordinates': [
                                    userGuessLngLat.toArray(),
                                    actualLocationCoords.toArray()
                                ]
                            }
                        }
                    ]
                };

                if (mainMap.getSource('line-between-pins')) {
                    mainMap.getSource('line-between-pins').setData(lineGeoJSON);
                } else {
                    mainMap.addSource('line-between-pins', {
                        'type': 'geojson',
                        'data': lineGeoJSON
                    });
                    mainMap.addLayer({
                        'id': 'line-between-pins',
                        'type': 'line',
                        'source': 'line-between-pins',
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        'paint': {
                            'line-color': '#888',
                            'line-width': 4
                        }
                    });
                }
                lineLayerVisible = true;
            }
        }

        function removeLineBetweenPins() {
            if (mainMap && mainMap.getLayer('line-between-pins')) {
                mainMap.removeLayer('line-between-pins');
                mainMap.removeSource('line-between-pins');
                lineLayerVisible = false;
            }
        }

        // --- Pin Management ---
        function createPinElement(className) {
            const el = document.createElement('div');
            el.className = className;
            return el;
        }

        function placeGuessPin(lngLat) {
            if (guessPinElement) {
                guessPinElement.remove();
            }
            userGuessLngLat = convertToLngLat(lngLat);
            if (!userGuessLngLat) return;

            guessPinElement = createPinElement('guess-pin');
            new maptilersdk.Marker({ element: guessPinElement })
                .setLngLat(userGuessLngLat)
                .addTo(overlayMap);

            DOM.guessedCoordsText.textContent = `Guessed: ${userGuessLngLat.lng.toFixed(4)}, ${userGuessLngLat.lat.toFixed(4)}`;
            DOM.submitStatusText.textContent = `Guess placed! Click "Submit Guess"`;
            DOM.submitGuessBtn.disabled = false;
        }

        function updateGuessPinPositionHandler() {
            if (guessPinElement && userGuessLngLat) {
                const mapRect = DOM.overlayMapElement.getBoundingClientRect();
                const pixel = overlayMap.project(userGuessLngLat);
                guessPinElement.style.left = `${pixel.x}px`;
                guessPinElement.style.top = `${pixel.y}px`;
            }
        }

        function placeRealLocationPin(lngLat) {
            if (realLocationPinElement) {
                realLocationPinElement.remove();
            }
            actualLocationCoords = convertToLngLat(lngLat);
            if (!actualLocationCoords) return;

            realLocationPinElement = createPinElement('real-location-pin');
            new maptilersdk.Marker({ element: realLocationPinElement })
                .setLngLat(actualLocationCoords)
                .addTo(mainMap);

            mainMap.flyTo({ center: actualLocationCoords, zoom: INITIAL_ZOOM_LEVEL, essential: true });
        }

        function updateRealLocationPinPositionHandler() {
            if (realLocationPinElement && actualLocationCoords) {
                const mapRect = DOM.mapsContainer.getBoundingClientRect(); // Use main map container for real location
                const pixel = mainMap.project(actualLocationCoords);
                realLocationPinElement.style.left = `${pixel.x}px`;
                realLocationPinElement.style.top = `${pixel.y}px`;
            }
        }

        function clearPinsAndLine() {
            if (guessPinElement) {
                guessPinElement.remove();
                guessPinElement = null;
            }
            if (realLocationPinElement) {
                realLocationPinElement.remove();
                realLocationPinElement = null;
            }
            removeLineBetweenPins();
            userGuessLngLat = null;
            actualLocationCoords = null;
        }

        // --- Map Initialization ---
        function initializeMainMap() {
            return new maptilersdk.Map({
                container: 'maptiler-map',
                style: MAIN_MAP_STYLE_URL,
                zoom: INITIAL_ZOOM_LEVEL,
                center: [0, 0] // Will be set to actual location later
            });
        }

        function initializeOverlayMap() {
            return new maptilersdk.Map({
                container: 'overlay-map',
                style: OVERLAY_MAP_STYLE_URL,
                zoom: OVERLAY_INITIAL_ZOOM,
                center: OVERLAY_INITIAL_CENTER,
                hash: false,
                navigationControl: false,
                geolocateControl: false,
                attributionControl: false
            });
        }

        function addGlobalEventListeners() {
            // Overlay map click/contextmenu handler for placing guess pin
            const placeGuessPinHandler = (e) => {
                if (gameInProgress) {
                    placeGuessPin(e.lngLat);
                }
            };
            overlayMap.on('click', placeGuessPinHandler);
            overlayMap.on('contextmenu', placeGuessPinHandler);

            // Overlay map transition handler
            DOM.overlayMapElement.addEventListener('transitionend', () => {
                if (overlayMap) {
                    overlayMap.resize();
                    if (guessPinElement && userGuessLngLat) updateGuessPinPositionHandler();
                    if (realLocationPinElement && actualLocationCoords) updateRealLocationPinPositionHandler();
                    updateLineBetweenPins();
                }
            });

            // Button click handlers
            DOM.submitGuessBtn.addEventListener('click', handleSubmitGuess);
        }

        // --- Game Logic ---
        async function fetchRandomCity() {
            DOM.locationText.textContent = 'Finding a new location...';
            DOM.submitStatusText.textContent = 'Please wait...';
            DOM.submitGuessBtn.disabled = true;

            let cityData = null;
            for (let i = 0; i < MAX_LOCATION_RETRIES; i++) {
                try {
                    const response = await fetch(API_BASE_URL + '/random-city');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    
                    const newLocation = data.coordinates;
                    if (newLocation && newLocation.length === 2 && typeof newLocation[0] === 'number' && typeof newLocation[1] === 'number') {
                        cityData = data;
                        break;
                    } else {
                        console.warn('Invalid coordinates received, retrying...');
                    }
                } catch (error) {
                    console.error('Error fetching random city:', error);
                }
                await new Promise(resolve => setTimeout(resolve, 500)); // Wait a bit before retrying
            }

            if (!cityData) {
                DOM.locationText.textContent = 'Failed to load a location after multiple retries.';
                DOM.submitStatusBtn.disabled = true;
                showNotification('Failed to find a random city. Please try again.', 'error');
                return null;
            }

            DOM.locationText.textContent = `Location: ${cityData.city}, ${cityData.country}`;
            DOM.submitStatusText.textContent = 'Place your guess on the overlay map...';
            return convertToLngLat(cityData.coordinates);
        }

        async function startNewRound(coords) {
            clearPinsAndLine();
            actualLocationCoords = coords;

            if (mainMap) {
                mainMap.flyTo({ center: actualLocationCoords, zoom: INITIAL_ZOOM_LEVEL, essential: true });
            }

            userGuessLngLat = null; // Reset user guess for new round
            DOM.guessedCoordsText.textContent = 'Make your guess on the overlay map...';
            DOM.submitStatusText.textContent = 'Place your guess on the overlay map...';
            DOM.pointsScoreText.textContent = 'Points: - | Total: ' + totalScore + ' points';
            DOM.submitGuessBtn.disabled = true; // Disable submit until a guess is placed

            // Ensure maps are resized
            if (mainMap) mainMap.resize();
            if (overlayMap) overlayMap.resize();
        }

        async function handleSubmitGuess() {
            if (!userGuessLngLat || !actualLocationCoords || !playerId || !sessionCode) {
                showNotification('Please place your guess on the map first.', 'error');
                return;
            }

            DOM.submitGuessBtn.disabled = true; // Prevent multiple submissions
            DOM.submitStatusText.textContent = 'Submitting guess...';

            const { distance, score } = calculateGeoGuessrScore(
                userGuessLngLat.lat, userGuessLngLat.lng,
                actualLocationCoords.lat, actualLocationCoords.lng
            );

            // Display actual location and line on main map
            placeRealLocationPin(actualLocationCoords);
            addLineBetweenPins();

            DOM.pointsScoreText.textContent = `Points: ${score} | Total: ${totalScore + score} points`;
            DOM.submitStatusText.textContent = `Distance: ${distance.toFixed(2)} meters! You scored ${score} points!`;

            // Send guess to WebSocket server
            gameWebSocket.send({
                type: 'submit_guess',
                sessionCode: sessionCode,
                playerId: playerId,
                guess: {
                    lat: userGuessLngLat.lat,
                    lng: userGuessLngLat.lng
                },
                score: score,
                distance: distance
            });
        }

        function updateLeaderboard(leaderboardData) {
            const leaderboardContent = DOM.leaderboardContent;
            if (!leaderboardData || leaderboardData.length === 0) {
                leaderboardContent.innerHTML = '<p>No scores yet. Be the first!</p>';
                return;
            }

            let tableHtml = `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Score</th>
                            <th>Last Round</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            leaderboardData.sort((a, b) => b.totalScore - a.totalScore); // Sort by total score
            leaderboardData.forEach((player, index) => {
                const isCurrentUser = player.playerId === playerId;
                tableHtml += `
                    <tr class="${isCurrentUser ? 'current-player' : ''}">
                        <td>${index + 1}</td>
                        <td>${player.playerName} ${isCurrentUser ? '(You)' : ''}</td>
                        <td>${player.totalScore}</td>
                        <td>${player.lastRoundScore !== undefined ? player.lastRoundScore : '-'}</td>
                    </tr>
                `;
            });
            tableHtml += `</tbody></table>`;
            leaderboardContent.innerHTML = tableHtml;
        }

        function updateGameStatus(status) {
            DOM.liveStatus.textContent = status.gameState || 'N/A';
            DOM.livePlayersCount.textContent = status.playerCount || '0';
            DOM.liveConnections.textContent = status.connections || '0';
            DOM.roundCountText.textContent = `Round: ${status.currentRound || 1} | Game: ${status.currentGame || 1}`;
            currentRound = status.currentRound || 1;
            currentGame = status.currentGame || 1;
            totalScore = (sessionData.leaderboard.find(p => p.playerId === playerId) || {}).totalScore || 0;
            DOM.pointsScoreText.textContent = `Points: - | Total: ${totalScore} points`;
        }

        // --- WebSocket Management ---
        class GameWebSocket {
            constructor(sessionCode) {
                this.sessionCode = sessionCode;
                this.ws = null;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectAttempts = 0;
                this.connect();
            }

            connect() {
                try {
                    updateConnectionStatus('connecting');
                    const WS_BASE_URL = 'wss://game-session-worker.games-6cb.workers.dev';
                    const wsUrl = `${WS_BASE_URL}/ws?session=${this.sessionCode}`;

                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        updateConnectionStatus('connected');
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 1000;
                        // Request initial session update
                        this.send({ type: 'request_update' });
                        // Send ping every 30 seconds
                        this.pingInterval = setInterval(() => {
                            if (this.ws?.readyState === WebSocket.OPEN) {
                                this.send({ type: 'ping' });
                            }
                        }, 30000);
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                        }
                    };

                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        updateConnectionStatus('disconnected');
                        if (this.pingInterval) {
                            clearInterval(this.pingInterval);
                        }
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        updateConnectionStatus('disconnected');
                    };
                } catch (error) {
                    console.error('Error creating WebSocket:', error);
                    updateConnectionStatus('disconnected');
                    this.scheduleReconnect();
                }
            }

            send(message) {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                } else {
                    console.warn('WebSocket not connected, message not sent:', message);
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'session_update':
                        handleSessionUpdate(message.data);
                        if (message.event) {
                            handleSessionEvent(message.event);
                        }
                        break;
                    case 'join_success':
                        showNotification('Successfully joined the game!', 'success');
                        break;
                    case 'score_success':
                        showNotification(`Score posted! Total: ${message.totalScore}`, 'success');
                        totalScore = message.totalScore; // Update client's total score
                        // The session_update will handle full leaderboard refresh
                        break;
                    case 'session_deleted':
                        showNotification('Session was deleted by admin', 'error');
                        resetToJoinScreen();
                        break;
                    case 'error':
                        showNotification(`Error: ${message.message}`, 'error');
                        break;
                    case 'pong':
                        // Server responded to ping
                        break;
                    case 'connected':
                        console.log('WebSocket:', message.message);
                        break;
                    default:
                        console.log('Unknown message type:', message.type, message);
                }
            }

            scheduleReconnect() {
                if (!sessionCode) return; // Don't reconnect if we've left the session
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay);
                console.log(`Attempting to reconnect in ${delay / 1000} seconds...`);
                setTimeout(() => this.connect(), delay);
            }

            close() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                if (this.pingInterval) {
                    clearInterval(this.pingInterval);
                }
            }
        }

        // --- Session Management ---
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        async function joinSession() {
            sessionCode = document.getElementById('session-code').value.trim();
            playerName = document.getElementById('player-name').value.trim();

            if (!sessionCode || !playerName) {
                DOM.joinMessage.textContent = 'Please enter both session code and your name.';
                DOM.joinMessage.className = 'error-message';
                return;
            }

            DOM.joinMessage.textContent = 'Attempting to join session...';
            DOM.joinMessage.className = 'waiting-message';
            DOM.joinButton.disabled = true;

            try {
                const response = await fetch(API_BASE_URL + '/join-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sessionCode, playerName })
                });

                const result = await response.json();

                if (response.ok) {
                    playerId = result.playerId || generatePlayerId(); // Use server-provided ID or generate
                    showNotification('Successfully joined session!', 'success');
                    DOM.joinMessage.textContent = '';
                    DOM.sessionJoin.style.display = 'none';
                    DOM.sessionWaiting.style.display = 'block';
                    updateSessionInfo(result.session);
                    gameWebSocket = new GameWebSocket(sessionCode);
                } else {
                    DOM.joinMessage.textContent = result.message || 'Failed to join session.';
                    DOM.joinMessage.className = 'error-message';
                }
            } catch (error) {
                console.error('Error joining session:', error);
                DOM.joinMessage.textContent = 'Network error or server unavailable.';
                DOM.joinMessage.className = 'error-message';
            } finally {
                DOM.joinButton.disabled = false;
            }
        }

        function updateSessionInfo(session) {
            sessionData = session;
            DOM.sessionInfo.innerHTML = `
                <p><strong>Session Code:</strong> ${session.sessionCode}</p>
                <p><strong>Admin:</strong> ${session.adminName}</p>
                <p><strong>Players:</strong> ${session.playerCount}</p>
                <p><strong>Status:</strong> ${session.gameState}</p>
            `;
            updateLivePlayersList(session.players);
            updateGameStatus(session);

            if (session.gameState === 'in_progress') {
                DOM.startButton.style.display = 'none';
                showGameScreen();
                if (session.currentLocation) {
                    startNewRound(convertToLngLat(session.currentLocation));
                }
            } else if (session.adminId === playerId) {
                DOM.startButton.style.display = 'block';
            } else {
                DOM.startButton.style.display = 'none';
            }
            updateLeaderboard(session.leaderboard || []);
        }

        function updateLivePlayersList(players) {
            const playersList = DOM.playersListElement;
            playersList.innerHTML = '';
            if (!players || players.length === 0) {
                playersList.innerHTML = '<p>No other players yet.</p>';
                return;
            }
            players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `player-item ${player.playerId === playerId ? 'you' : ''}`;
                if (player.status === 'left') playerDiv.classList.add('left');
                if (player.status === 'kicked') playerDiv.classList.add('kicked');
                
                playerDiv.innerHTML = `
                    <span class="player-name">${player.playerName}</span>
                    <span class="player-score">${player.totalScore !== undefined ? player.totalScore : '-'}</span>
                `;
                playersList.appendChild(playerDiv);
            });
        }

        function handleSessionEvent(event) {
            switch (event.type) {
                case 'player_joined':
                    showNotification(`${event.playerName} joined the session.`, 'info');
                    break;
                case 'player_left':
                    showNotification(`${event.playerName} left the session.`, 'info');
                    break;
                case 'player_kicked':
                    showNotification(`${event.playerName} was kicked.`, 'warning');
                    if (event.playerId === playerId) {
                        showNotification('You have been kicked from the session.', 'error');
                        resetToJoinScreen();
                    }
                    break;
                case 'game_started':
                    showNotification('The game has started!', 'success');
                    showGameScreen();
                    gameInProgress = true;
                    if (event.currentLocation) {
                        startNewRound(convertToLngLat(event.currentLocation));
                    }
                    break;
                case 'new_round':
                    showNotification('New round started!', 'info');
                    gameInProgress = true;
                    if (event.currentLocation) {
                        startNewRound(convertToLngLat(event.currentLocation));
                    }
                    DOM.submitGuessBtn.disabled = false; // Enable submit for new round
                    break;
                case 'game_ended':
                    showNotification('The game has ended!', 'info');
                    gameInProgress = false;
                    // Optionally show final scores or reset
                    break;
                default:
                    console.log('Unhandled session event:', event);
            }
        }

        async function startGame() {
            if (!sessionCode || !playerId) {
                showNotification('Session not properly set up to start game.', 'error');
                return;
            }
            DOM.startButton.disabled = true;
            DOM.waitMessage.textContent = 'Starting game...';
            DOM.waitMessage.className = 'waiting-message';

            try {
                const response = await fetch(API_BASE_URL + '/start-game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sessionCode, playerId })
                });
                const result = await response.json();
                if (response.ok) {
                    showNotification('Game started successfully!', 'success');
                    DOM.waitMessage.textContent = '';
                    showGameScreen();
                    gameInProgress = true;
                    if (result.session.currentLocation) {
                        startNewRound(convertToLngLat(result.session.currentLocation));
                    }
                } else {
                    DOM.waitMessage.textContent = result.message || 'Failed to start game.';
                    DOM.waitMessage.className = 'error-message';
                }
            } catch (error) {
                console.error('Error starting game:', error);
                DOM.waitMessage.textContent = 'Network error or server unavailable.';
                DOM.waitMessage.className = 'error-message';
            } finally {
                DOM.startButton.disabled = false;
            }
        }

        function showGameScreen() {
            DOM.sessionWaiting.style.display = 'none';
            DOM.sessionJoin.style.display = 'none';
            DOM.gameContainer.style.display = 'block';
            // Ensure maps resize after container becomes visible
            if (mainMap) mainMap.resize();
            if (overlayMap) overlayMap.resize();
        }

        function resetToJoinScreen() {
            DOM.sessionJoin.style.display = 'block';
            DOM.sessionWaiting.style.display = 'none';
            DOM.gameContainer.style.display = 'none';
            sessionCode = null;
            playerName = null;
            playerId = null;
            sessionData = null;
            currentRound = 1;
            currentGame = 1;
            totalScore = 0;
            gameInProgress = false;
            if (gameWebSocket) {
                gameWebSocket.close();
            }
            clearPinsAndLine();
            DOM.joinMessage.textContent = '';
            DOM.sessionCode.value = '';
            DOM.playerName.value = '';
            updateConnectionStatus('disconnected');
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements();
            updateConnectionStatus('disconnected');
            
            mainMap = initializeMainMap();
            overlayMap = initializeOverlayMap();

            // Ensure overlayMap is fully loaded before attaching listeners that depend on it
            overlayMap.on('load', () => {
                 addGlobalEventListeners();
            });

            // Handle overlay map transitions
            DOM.overlayMapElement.addEventListener('transitionend', () => {
                if (overlayMap) {
                    overlayMap.resize();
                    if (guessPinElement && userGuessLngLat) updateGuessPinPositionHandler();
                    if (realLocationPinElement && actualLocationCoords) updateRealLocationPinPositionHandler();
                    updateLineBetweenPins();
                }
            });

            console.log('Maps initialized successfully');
            
        });

        // --- Cleanup on page unload ---
        window.addEventListener('beforeunload', () => {
            if (gameWebSocket) {
                gameWebSocket.close();
            }
        });
    </script>
</body>
</html>


