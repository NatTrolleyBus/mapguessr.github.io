<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
        }

        header {
            background-color: #0cc0df;
            padding: 20px;
            border-radius: 0 0 5px 5px;
        }
        h1 {
            color: #444;
            margin-top: 0;
        }
        main {
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        section {
            margin-bottom: 30px;
        }
        .maps-container {
            position: relative;
            height: 600px; /* Fixed height for the container */
            width: 100%;
            margin-bottom: 20px;
            overflow: hidden;
        }
        #maptiler-map {
            position: relative;
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
            background-color: #eaeaea;
        }
        #overlay-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 250px;
            height: 150px;
            border: 2px solid #555;
            border-radius: 5px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 10;
            transition: all 0.4s ease-in-out;
        }
        #overlay-map:hover:not(.overlay-map-fullscreen) {
            width: 400px;
            height: 300px;
        }
        .overlay-map-fullscreen {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important; /* Fill the entire maps-container */
            z-index: 100 !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important; /* Remove shadow when fullscreen */
        }
        .submit-container {
            text-align: center;
            margin-bottom: 30px;
        }
        .submit-btn, .new-location-btn {
            background-color: #0cc0df;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 0 10px;
        }
        .submit-btn:hover, .new-location-btn:hover {
            background-color: #0aa8c4;
        }
        footer {
            background-color: #0cc0df;
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            font-size: 0.9em;
            margin-top: 40px;
        }
        .maptiler-ctrl-group,
        .maptiler-ctrl,
        .maplibregl-ctrl-group,
        .maplibregl-ctrl {
            display: none !important;
        }
        .guess-pin {
            position: absolute;
            width: 24px; /* Width of the pin */
            height: 36px; /* Height of the pin */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%23e53e3e" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            transform: translate3d(-50%, -100%, 0);
            z-index: 101;
            pointer-events: none;
        }
        .real-location-pin {
            position: absolute;
            width: 24px; /* Width of the pin */
            height: 36px; /* Height of the pin */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%2328a745" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            transform: translate3d(-50%, -100%, 0);
            z-index: 102;
            pointer-events: none;
        }
        #next-round-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            font-size: 1.1em;
            background-color: #0cc0df;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 110; /* Ensure it's above the maps */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        #next-round-btn:hover {
            background-color: #0aa8c4;
        }
        #round-score-display, #total-score-display {
            position: fixed; /* Fixed position relative to viewport */
            padding: 10px 15px;
            background-color: black; /* Changed to solid black */
            color: white;
            font-size: 1.2em;
            border-radius: 5px;
            z-index: 1000; /* High z-index to be on top */
            display: none; /* Hidden by default */
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            border: 1px solid white; /* Added white border */
        }
        #round-score-display {
            bottom: 20px;
            left: 20px;
        }
        #total-score-display {
            bottom: 20px;
            right: 20px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Test</h1>
        <p>May 15th 2025 - V9 (Score Calculation Fix)</p>
        <div id="auth-container" style="padding-top: 10px;">
            <button id="login-btn" style="padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">Login</button>
            <button id="register-btn" style="padding: 8px 15px; background-color: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 10px;">Register</button>
            <button id="logout-btn" style="display:none; padding: 8px 15px; background-color: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; margin-left: 10px;">Logout</button>
            <span id="user-info" style="margin-left: 20px; color: #fff;"></span>
        </div>
    </header>
    <main style="display:none;">
        <section>
            <h2>About</h2>
            <p>Game Rules.</p>
        </section>
        <section>
            <h2>Maps</h2>
            <div class="maps-container">
                <div id="maptiler-map"></div>
                <div id="overlay-map"></div>
            </div>
            <div class="submit-container">
                <button class="new-location-btn" id="new-location">New Location</button>
                <button class="submit-btn" id="submit-guess">Submit</button>
            </div>
        </section>
        <section>
            <h2>Game Answers</h2>
            <ul>
                <li id="location-text">The location label/place goes here/coordinates</li>
                <li id="guessed-coords">The guessed coordinates</li>
                <li id="submit-status">Submit button clicked? status goes here</li>
                <li id="points-score">Future points/scores system goes here</li>
                <li id="round-count">Round: 1</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Made by Nathan and Jason</p>
    </footer>

    <div id="round-score-display"></div>
    <div id="total-score-display"></div>

    <script>
        // --- OAuth Configuration ---
        const OAUTH_CLIENT_ID = 'https://mapguessr-github-io.pages.dev/'; // IMPORTANT: Replace with your actual client_id from transitspotter
        const OAUTH_REDIRECT_URI = window.location.href.split('?')[0]; // Assumes the current page handles the callback and is registered
        const AUTH_SERVER_BASE_URL = 'https://auth.transitspotter.com';

        // --- Map Guessr Configuration ---
        const apiKey = 'ZS9RHHRim7f1OZRKuI6n';
        maptilersdk.config.apiKey = apiKey;
        const randomCityApiUrl = 'https://random-city-api.vercel.app/api/random-city';
        let currentMarker = null;
        let userGuessLngLat = null;
        let guessPinElement = null;
        let currentLocationCoords = null;
        let totalScore = 0;
        let mainMap = null;
        let overlayMap = null;
        let realLocationPinElement = null;
        let roundCount = 1;
        const zoomLevel = 15;
        const customStyleUrl = 'https://api.maptiler.com/maps/0196cb69-f55f-71f8-9a8f-90fa083f0f67/style.json?key=' + apiKey;
        const overlayStyleUrl = 'https://api.maptiler.com/maps/0196cb7f-9914-7a9b-aed1-8bfa7b9a0705/style.json?key=' + apiKey;
        const initialCenter = [0, 0];
        const initialZoom = -1.0;
        let lineLayerVisible = false;


        // --- Application State ---
        let isAuthenticated = false;

        // --- OAuth Helper Functions ---
        async function generateCodeVerifierAndChallenge() {
            const codeVerifier = generateRandomString(64);
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            const codeChallenge = btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
            return { codeVerifier, codeChallenge };
        }

        function generateRandomString(length) {
            const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
            let result = '';
            const randomValues = new Uint8Array(length);
            crypto.getRandomValues(randomValues);
            for (let i = 0; i < length; i++) {
                result += charset[randomValues[i] % charset.length];
            }
            return result;
        }

        async function startOAuthFlow() {
            const { codeVerifier, codeChallenge } = await generateCodeVerifierAndChallenge();
            const state = generateRandomString(32);
            sessionStorage.setItem('code_verifier', codeVerifier);
            sessionStorage.setItem('oauth_state', state);

            const authUrl = new URL(`${AUTH_SERVER_BASE_URL}/external/authorize`);
            authUrl.searchParams.append('response_type', 'code');
            authUrl.searchParams.append('client_id', OAUTH_CLIENT_ID);
            authUrl.searchParams.append('redirect_uri', OAUTH_REDIRECT_URI);
            authUrl.searchParams.append('code_challenge', codeChallenge);
            authUrl.searchParams.append('code_challenge_method', 'S256');
            authUrl.searchParams.append('state', state);
            window.location.href = authUrl.toString();
        }

        async function handleOAuthCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const error = urlParams.get('error');

            if (error) {
                console.error('OAuth error:', error, urlParams.get('error_description'));
                alert(`OAuth Error: ${error} - ${urlParams.get('error_description') || 'Unknown error'}`);
                return false;
            }

            const storedState = sessionStorage.getItem('oauth_state');
            if (!state || state !== storedState) {
                console.error('Invalid state parameter');
                alert('Error: Invalid state. CSRF attack suspected.');
                return false;
            }

            const codeVerifier = sessionStorage.getItem('code_verifier');
            if (!codeVerifier) {
                console.error('Code verifier not found');
                alert('Error: Code verifier missing. Please try logging in again.');
                return false;
            }

            try {
                const response = await fetch(`${AUTH_SERVER_BASE_URL}/external/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Origin': window.location.origin
                    },
                    body: JSON.stringify({
                        grant_type: 'authorization_code',
                        code: code,
                        client_id: OAUTH_CLIENT_ID,
                        redirect_uri: OAUTH_REDIRECT_URI,
                        code_verifier: codeVerifier
                    })
                });
                const tokenData = await response.json();

                if (tokenData.error) {
                    console.error('Token error:', tokenData.error, tokenData.error_description);
                    alert(`Token Error: ${tokenData.error} - ${tokenData.error_description || 'Failed to get token'}`);
                    return false;
                }

                localStorage.setItem('access_token', tokenData.access_token);
                localStorage.setItem('refresh_token', tokenData.refresh_token);
                localStorage.setItem('token_expiry', Date.now() + (tokenData.expires_in * 1000));

                sessionStorage.removeItem('code_verifier');
                sessionStorage.removeItem('oauth_state');
                return true;
            } catch (err) {
                console.error('Token exchange error:', err);
                alert('Error exchanging code for token. Please check console.');
                return false;
            }
        }

        async function refreshToken() {
            const refreshTokenVal = localStorage.getItem('refresh_token');
            if (!refreshTokenVal) return false;

            try {
                const response = await fetch(`${AUTH_SERVER_BASE_URL}/external/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Origin': window.location.origin
                    },
                    body: JSON.stringify({
                        grant_type: 'refresh_token',
                        refresh_token: refreshTokenVal,
                        client_id: OAUTH_CLIENT_ID
                    })
                });
                const tokenData = await response.json();

                if (tokenData.error) {
                    console.error('Refresh error:', tokenData.error, tokenData.error_description);
                    localStorage.clear();
                    return false;
                }
                localStorage.setItem('access_token', tokenData.access_token);
                if (tokenData.refresh_token) {
                    localStorage.setItem('refresh_token', tokenData.refresh_token);
                }
                localStorage.setItem('token_expiry', Date.now() + (tokenData.expires_in * 1000));
                return true;
            } catch (error) {
                console.error('Token refresh error:', error);
                return false;
            }
        }

        async function ensureValidToken() {
            const accessToken = localStorage.getItem('access_token');
            if (!accessToken) return false;

            const expiryTime = parseInt(localStorage.getItem('token_expiry'), 10);
            if (isNaN(expiryTime)) {
                localStorage.clear();
                return false;
            }
            if (Date.now() > expiryTime - 60000) { // Refresh if expiring in the next minute
                console.log("Token expired or expiring soon, attempting refresh...");
                return await refreshToken();
            }
            return true;
        }

        async function appLogout() {
            const refreshTokenVal = localStorage.getItem('refresh_token');
            if (refreshTokenVal) {
                try {
                    await fetch(`${AUTH_SERVER_BASE_URL}/external/revoke`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Origin': window.location.origin
                        },
                        body: JSON.stringify({
                            token: refreshTokenVal,
                            token_type_hint: 'refresh_token'
                        })
                    });
                } catch (error) {
                    console.error('Error revoking token:', error);
                }
            }
            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
            localStorage.removeItem('token_expiry');
            isAuthenticated = false;
            resetGameAndUI();
            updateAuthUI();
        }
        
        function resetGameAndUI() {
            // Remove map instances if they exist
            if (mainMap) { mainMap.remove(); mainMap = null; }
            if (overlayMap) { overlayMap.remove(); overlayMap = null; }

            // Clear markers and pins
            if (currentMarker) { currentMarker.remove(); currentMarker = null; }
            if (guessPinElement) { guessPinElement.remove(); guessPinElement = null; }
            if (realLocationPinElement) { realLocationPinElement.remove(); realLocationPinElement = null; }
            
            // Reset game state variables
            userGuessLngLat = null;
            currentLocationCoords = null;
            totalScore = 0;
            roundCount = 1;
            lineLayerVisible = false; // Assuming this should be reset

            // Reset UI text elements
            document.getElementById('location-text').textContent = 'The location label/place goes here/coordinates';
            document.getElementById('guessed-coords').textContent = 'The guessed coordinates';
            document.getElementById('submit-status').textContent = 'Submit button clicked? status goes here';
            document.getElementById('points-score').textContent = 'Future points/scores system goes here';
            document.getElementById('round-count').textContent = 'Round: 1';
            
            const existingNextButton = document.getElementById('next-round-btn');
            if (existingNextButton) existingNextButton.remove();

            document.getElementById('round-score-display').style.display = 'none';
            document.getElementById('total-score-display').style.display = 'none';

            // Disable game buttons
            const submitGuessBtnElem = document.getElementById('submit-guess');
            if(submitGuessBtnElem) submitGuessBtnElem.disabled = true;
            const newLocationBtnElem = document.getElementById('new-location');
            if(newLocationBtnElem) newLocationBtnElem.disabled = true;
        }

        // --- UI Update Functions ---
        function updateAuthUI() {
            const loginBtn = document.getElementById('login-btn');
            const registerBtn = document.getElementById('register-btn');
            const logoutBtn = document.getElementById('logout-btn');
            const userInfoDisplay = document.getElementById('user-info');
            const gameContent = document.querySelector('main');

            if (isAuthenticated) {
                loginBtn.style.display = 'none';
                registerBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
                userInfoDisplay.textContent = `Logged In`; // You could fetch actual user info here
                gameContent.style.display = 'block'; // Show game content
                if (!mainMap) { // Initialize game only if not already done
                  initializeGame();
                }
            } else {
                loginBtn.style.display = 'inline-block';
                registerBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
                userInfoDisplay.textContent = ''; // Or "Please log in"
                gameContent.style.display = 'none'; // Hide game content
                if (mainMap) { // If maps were initialized, remove them and reset state
                    resetGameAndUI();
                }
            }
        }
        
        // --- Original Game Functions ---
        function getRandomCoordinateInBounds(bounds) {
            const minLng = bounds[0];
            const minLat = bounds[1];
            const maxLng = bounds[2];
            const maxLat = bounds[3];
            const buffer = 0.001;
            const bufferedMinLng = minLng + (maxLng - minLng) * buffer;
            const bufferedMinLat = minLat + (maxLat - minLat) * buffer;
            const bufferedMaxLng = maxLng - (maxLng - minLng) * buffer;
            const bufferedMaxLat = maxLat - (maxLat - minLat) * buffer;
            const randomLng = bufferedMinLng + (bufferedMaxLng - bufferedMinLng) * Math.random();
            const randomLat = bufferedMinLat + (bufferedMaxLat - bufferedMinLat) * Math.random();
            return [randomLng, randomLat];
        }

        function addOrUpdateMarker(lngLatInput) {
            const lngLatObject = Array.isArray(lngLatInput) ? new maptilersdk.LngLat(lngLatInput[0], lngLatInput[1]) : lngLatInput;
            if (!(lngLatObject instanceof maptilersdk.LngLat) || typeof lngLatObject.lng !== 'number' || typeof lngLatObject.lat !== 'number') {
                console.error("addOrUpdateMarker received invalid LngLat data:", lngLatInput);
                return;
            }
            if (currentMarker) {
                currentMarker.remove();
            }
            currentMarker = new maptilersdk.Marker()
                .setLngLat(lngLatObject)
                .addTo(mainMap);
            currentLocationCoords = lngLatObject;
            if (currentMarker && currentMarker.getElement()) {
                currentMarker.getElement().style.display = 'none';
            }
            console.log("currentLocationCoords set to LngLat object:", currentLocationCoords);
        }

        function calculateDistanceInMeters(lat1, lon1, lat2, lon2) {
            if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number') {
                console.error("Invalid input types for calculateDistanceInMeters:", lat1, lon1, lat2, lon2);
                return NaN;
            }
            const R = 6371e3; // Earth's radius in meters
            const φ1 = lat1 * Math.PI / 180; // φ, λ in radians
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(Math.max(0, a)), Math.sqrt(Math.max(0, 1 - a)));
            const distance = R * c; // Distance in meters
            return distance;
        }

        function calculateGeoGuessrScore(lat1, lon1, lat2, lon2) {
            const MAX_SCORE = 5000; // Maximum points per round
            const FIVE_K_THRESHOLD_METERS = 100; // A small distance for a guaranteed 5000
            const distance = calculateDistanceInMeters(lat1, lon1, lat2, lon2);
            if (isNaN(distance)) {
                console.error("Distance calculation returned NaN.");
                return { distance: NaN, score: NaN }; // Propagate NaN if distance is invalid
            }
            let score;
            if (distance <= FIVE_K_THRESHOLD_METERS) {
                score = MAX_SCORE;
            } else {
                const decayFactor = 2000000; // Adjust based on desired scoring curve
                score = MAX_SCORE * Math.exp(-distance / decayFactor);
                score = Math.max(0, Math.round(score));
            }
            return { distance: distance, score: score };
        }

        function updateGuessPinPosition() {
            if (!overlayMap || !userGuessLngLat || !guessPinElement) return;
            if (!(userGuessLngLat instanceof maptilersdk.LngLat) || typeof userGuessLngLat.lng !== 'number' || typeof userGuessLngLat.lat !== 'number') {
                console.error("Invalid userGuessLngLat object for positioning:", userGuessLngLat);
                return;
            }
            const pixelCoords = overlayMap.project(userGuessLngLat);
            guessPinElement.style.left = `${pixelCoords.x}px`;
            guessPinElement.style.top = `${pixelCoords.y}px`;
            guessPinElement.style.display = 'block';
        }

        function updateRealLocationPinPosition() {
            if (!overlayMap || !currentLocationCoords || !realLocationPinElement) return;
            if (!(currentLocationCoords instanceof maptilersdk.LngLat) || typeof currentLocationCoords.lng !== 'number' || typeof currentLocationCoords.lat !== 'number') {
                console.error("Invalid currentLocationCoords object for positioning:", currentLocationCoords);
                return;
            }
            const pixelCoords = overlayMap.project(currentLocationCoords);
            realLocationPinElement.style.left = `${pixelCoords.x}px`;
            realLocationPinElement.style.top = `${pixelCoords.y}px`;
            realLocationPinElement.style.display = 'block';
        }
        
        function placeCustomGuessPinOnOverlay(lngLat) {
            console.log('Attempting to place custom guess pin at LngLat:', lngLat);
            userGuessLngLat = lngLat;
            if (guessPinElement) {
                console.log('Removing existing custom guess pin element.');
                guessPinElement.remove();
            }
            guessPinElement = document.createElement('div');
            guessPinElement.className = 'guess-pin';
            overlayMap.getCanvasContainer().appendChild(guessPinElement);
            console.log('New custom guess pin element created:', guessPinElement);
            updateGuessPinPosition();
            document.getElementById('guessed-coords').textContent = `Guessed Location: Lng: ${lngLat.lng.toFixed(6)}, Lat: ${lngLat.lat.toFixed(6)}`;
            document.getElementById('submit-status').textContent = 'Guess placed. Click Submit!';
            overlayMap.off('move', updateGuessPinPosition); // Remove previous to avoid duplicates
            overlayMap.on('move', updateGuessPinPosition);
            console.log("Guess pin placed and move listener added. userGuessLngLat:", userGuessLngLat);
        }

        function placeCustomRealLocationPinOnOverlay(lngLat) {
            console.log('Attempting to place custom real location pin at LngLat:', lngLat);
            if (realLocationPinElement) {
                console.log('Removing existing custom real location pin element.');
                realLocationPinElement.remove();
            }
            realLocationPinElement = document.createElement('div');
            realLocationPinElement.className = 'real-location-pin';
            overlayMap.getCanvasContainer().appendChild(realLocationPinElement);
            console.log('New custom real location pin element created:', realLocationPinElement);
            updateRealLocationPinPosition();
            overlayMap.off('move', updateRealLocationPinPosition); // Remove previous to avoid duplicates
            overlayMap.on('move', updateRealLocationPinPosition);
            console.log("Real location pin placed and move listener added. currentLocationCoords:", currentLocationCoords);
        }
        
        function updateLineBetweenPins() {
            if (!lineLayerVisible || !overlayMap || !userGuessLngLat || !currentLocationCoords) return;
            if (!(userGuessLngLat instanceof maptilersdk.LngLat) || typeof userGuessLngLat.lng !== 'number' || typeof userGuessLngLat.lat !== 'number' ||
                !(currentLocationCoords instanceof maptilersdk.LngLat) || typeof currentLocationCoords.lng !== 'number' || typeof currentLocationCoords.lat !== 'number') {
                console.error("Invalid LngLat objects for drawing line:", userGuessLngLat, currentLocationCoords);
                return;
            }
            const lineGeoJSON = {
                'type': 'Feature',
                'geometry': { 'type': 'LineString', 'coordinates': [ [userGuessLngLat.lng, userGuessLngLat.lat], [currentLocationCoords.lng, currentLocationCoords.lat] ] }
            };
            if (overlayMap.getSource('line-source')) {
                overlayMap.getSource('line-source').setData(lineGeoJSON);
            }
        }

        async function findRandomCityAndSpot(attempt = 1) {
            const locationText = document.getElementById('location-text');
            const newLocationBtn = document.getElementById('new-location');
            const submitGuessBtn = document.getElementById('submit-guess');

            locationText.textContent = 'Finding a new location...';
            document.getElementById('guessed-coords').textContent = 'Make your guess on the overlay map...';
            document.getElementById('submit-status').textContent = 'Place your guess on the overlay map...';
            document.getElementById('points-score').textContent = 'Points: - | Total: ' + totalScore + ' points';
            document.getElementById('round-score-display').style.display = 'none';
            document.getElementById('total-score-display').style.display = 'none';

            if (currentMarker) { currentMarker.remove(); currentMarker = null; }
            if (guessPinElement) {
                guessPinElement.remove(); guessPinElement = null;
                userGuessLngLat = null;
                if(overlayMap) overlayMap.off('move', updateGuessPinPosition);
                console.log("Custom guess pin element and move listener removed.");
            }
            if (realLocationPinElement) { realLocationPinElement.remove(); realLocationPinElement = null; if(overlayMap) overlayMap.off('move', updateRealLocationPinPosition); }
            currentLocationCoords = null;

            if (overlayMap && overlayMap.getLayer('line-layer')) {
                overlayMap.setLayoutProperty('line-layer', 'visibility', 'none');
                lineLayerVisible = false;
            }

            const existingNextButton = document.getElementById('next-round-btn');
            if (existingNextButton) existingNextButton.remove();

            submitGuessBtn.disabled = false;
            newLocationBtn.disabled = false;

            const MAX_LOCATION_RETRIES = 10;
            if (attempt > MAX_LOCATION_RETRIES) {
                locationText.textContent = `Failed to find a valid city location after ${MAX_LOCATION_RETRIES} attempts. Please check the console for errors.`;
                console.error(`Failed to find a valid city location after ${MAX_LOCATION_RETRIES} attempts.`);
                return;
            }
            console.log(`Attempting to find random city (Attempt ${attempt}/${MAX_LOCATION_RETRIES})...`);
            locationText.textContent = `Finding a random city (Attempt ${attempt})...`;

            try {
                const cityResponse = await fetch(randomCityApiUrl);
                if (!cityResponse.ok) throw new Error(`HTTP error fetching random city: ${cityResponse.status}`);
                const cityData = await cityResponse.json();
                const cityName = cityData.city;
                if (!cityName) {
                    console.warn(`Random City API returned no city name (Attempt ${attempt}). Retrying...`);
                    findRandomCityAndSpot(attempt + 1);
                    return;
                }
                console.log(`Successfully fetched city: ${cityName}. Finding geocoding data...`);
                locationText.textContent = `Finding a random spot in ${cityName}...`;

                const geocodingUrl = `https://api.maptiler.com/geocoding/${encodeURIComponent(cityName)}.json?key=${apiKey}`;
                const geocodingResponse = await fetch(geocodingUrl);
                if (!geocodingResponse.ok) {
                    console.warn(`HTTP error geocoding "${cityName}" (Attempt ${attempt}): ${geocodingResponse.status}. Retrying...`);
                    findRandomCityAndSpot(attempt + 1);
                    return;
                }
                const geocodingData = await geocodingResponse.json();
                if (geocodingData && geocodingData.features && geocodingData.features.length > 0) {
                    const feature = geocodingData.features[0];
                    const bounds = feature.bbox;
                    const center = feature.center;
                    let randomLngLatArray;
                    if (bounds) {
                        randomLngLatArray = getRandomCoordinateInBounds(bounds);
                        console.log("Using bounds to find random coordinate array:", randomLngLatArray);
                    } else if (center) {
                        const randomLng = center[0] + (Math.random() - 0.5) * 0.02;
                        const randomLat = center[1] + (Math.random() - 0.5) * 0.02;
                        randomLngLatArray = [randomLng, randomLat];
                        console.log("Using center with offset to find random coordinate array:", randomLngLatArray);
                    } else {
                        console.warn(`MapTiler Geocoding could not find detailed location data for "${cityName}" (Attempt ${attempt}). Retrying...`);
                        findRandomCityAndSpot(attempt + 1);
                        return;
                    }
                    console.log("Setting main map view to:", randomLngLatArray, "at zoom", zoomLevel);
                    if (mainMap) {
                        mainMap.jumpTo({ center: randomLngLatArray, zoom: zoomLevel, essential: true });
                    } else {
                        console.error("mainMap not initialized when trying to jumpTo.");
                    }
                    document.getElementById('location-text').textContent = `Location: A random spot in ${feature.place_name || cityName}`;
                    addOrUpdateMarker(randomLngLatArray);
                    console.log("New location setup complete via API. currentLocationCoords:", currentLocationCoords);
                } else {
                    console.warn(`MapTiler Geocoding could not find the location for "${cityName}" (Attempt ${attempt}). Retrying...`);
                    findRandomCityAndSpot(attempt + 1);
                }
            } catch (error) {
                console.error(`Error during API call (Attempt ${attempt}):`, error);
                locationText.textContent = `An error occurred fetching location: ${error.message}. Retrying...`;
                findRandomCityAndSpot(attempt + 1);
            }
        }
        
        // --- Game Initialization (Called after successful authentication) ---
        function initializeGame() {
            if (mainMap) return; // Ensure this runs only once

            const newLocationBtn = document.getElementById('new-location');
            const submitGuessBtn = document.getElementById('submit-guess');
            const roundScoreDisplay = document.getElementById('round-score-display');
            const totalScoreDisplay = document.getElementById('total-score-display');

            mainMap = new maptilersdk.Map({
                container: 'maptiler-map',
                style: customStyleUrl,
                center: [0, 0],
                zoom: 1,
                interactive: false
            });

            overlayMap = new maptilersdk.Map({
                container: 'overlay-map',
                style: overlayStyleUrl,
                center: initialCenter,
                zoom: initialZoom,
                interactive: true
            });
            
            mainMap.on('error', (e) => {
                console.error('Main map loading error:', e.error);
                document.getElementById('location-text').textContent = "Error loading main map. Check console.";
            });
            overlayMap.on('error', (e) => {
                console.error('Overlay map loading error:', e.error);
                document.getElementById('guessed-coords').textContent = "Error loading overlay map. Check console.";
            });

            mainMap.on('style.load', () => {
                console.log('Main map style loaded.');
                findRandomCityAndSpot();
                try {
                    mainMap.getContainer().querySelectorAll('.maptiler-ctrl, .maplibregl-ctrl').forEach(ctrl => ctrl.remove());
                } catch (e) { console.warn("Could not remove controls programmatically for main map:", e); }
            });

            overlayMap.on('style.load', () => {
                console.log('Overlay map style loaded.');
                try {
                    overlayMap.getContainer().querySelectorAll('.maptiler-ctrl, .maplibregl-ctrl').forEach(ctrl => ctrl.remove());
                } catch (e) { console.warn("Could not remove controls programmatically for overlay map:", e); }

                overlayMap.addSource('line-source', {
                    'type': 'geojson',
                    'data': { 'type': 'Feature', 'geometry': { 'type': 'LineString', 'coordinates': [] } }
                });
                overlayMap.addLayer({
                    'id': 'line-layer', 'type': 'line', 'source': 'line-source',
                    'layout': { 'line-join': 'round', 'line-cap': 'round', 'visibility': 'none' },
                    'paint': { 'line-color': '#000', 'line-width': 2, 'line-dasharray': [0.5, 2] }
                });
                overlayMap.on('move', updateLineBetweenPins);
            });

            overlayMap.on('click', (e) => {
                if (!overlayMap.getContainer().classList.contains('overlay-map-fullscreen')) {
                    const clickedLngLat = e.lngLat;
                    console.log('Overlay map left-clicked at:', clickedLngLat);
                    placeCustomGuessPinOnOverlay(clickedLngLat);
                }
            });
            overlayMap.on('contextmenu', (e) => {
                e.preventDefault();
                if (!overlayMap.getContainer().classList.contains('overlay-map-fullscreen')) {
                    const clickedLngLat = e.lngLat;
                    console.log('Overlay map right-clicked at:', clickedLngLat);
                    placeCustomGuessPinOnOverlay(clickedLngLat);
                }
            });
            
            const overlayMapElement = document.getElementById('overlay-map');
            overlayMapElement.addEventListener('transitionend', () => {
                console.log('Overlay map container transition ended. Resizing map.');
                if (overlayMap) {
                    overlayMap.resize();
                    if (guessPinElement && userGuessLngLat) updateGuessPinPosition();
                    if (realLocationPinElement && currentLocationCoords) updateRealLocationPinPosition();
                    updateLineBetweenPins();
                }
            });

            newLocationBtn.addEventListener('click', findRandomCityAndSpot);
            
            submitGuessBtn.addEventListener('click', function handleSubmitGuess() {
                console.log("Submit button clicked.");
                if (!userGuessLngLat || !(userGuessLngLat instanceof maptilersdk.LngLat)) {
                    document.getElementById('submit-status').textContent = 'Please make a guess by clicking or right-clicking on the map.';
                    console.warn("Submit clicked without a valid guess location.");
                    return;
                }
                if (!currentLocationCoords || !(currentLocationCoords instanceof maptilersdk.LngLat)) {
                    document.getElementById('submit-status').textContent = 'Error: No location set for scoring.';
                    console.error('Error: Submit clicked but currentLocationCoords is null or not a LngLat object.');
                    return;
                }
                const guessedLngLat = userGuessLngLat;
                const actualLngLat = currentLocationCoords;
                console.log("Actual LngLat for scoring:", actualLngLat);
                console.log("Guessed LngLat for scoring:", guessedLngLat);
                if (typeof actualLngLat.lat !== 'number' || typeof actualLngLat.lng !== 'number' || typeof guessedLngLat.lat !== 'number' || typeof guessedLngLat.lng !== 'number') {
                    console.error("Score Calculation Error: One or more coordinate values are not numbers.", {actual: actualLngLat, guessed: guessedLngLat});
                    document.getElementById('submit-status').textContent = 'Error: Cannot calculate score due to invalid coordinate data.';
                    return;
                }
                const scoreResult = calculateGeoGuessrScore(actualLngLat.lat, actualLngLat.lng, guessedLngLat.lat, guessedLngLat.lng);
                console.log("Score Calculation Result:", scoreResult);
                if (isNaN(scoreResult.score) || isNaN(scoreResult.distance)) {
                    console.error("Score calculation returned NaN.", scoreResult);
                    document.getElementById('submit-status').textContent = 'Error: Score calculation failed.';
                    return;
                }
                totalScore += scoreResult.score;
                document.getElementById('points-score').textContent = `Round Score: ${scoreResult.score} points (${(scoreResult.distance/1000).toFixed(2)} km) | Total Score: ${totalScore} points`;
                document.getElementById('submit-status').textContent = `Guess submitted! You were ${(scoreResult.distance/1000).toFixed(2)} km away.`;
                if (currentMarker && currentMarker.getElement()) {
                    currentMarker.getElement().style.display = 'block';
                    console.log("Showing actual location marker on main map.");
                } else { console.warn("Could not find currentMarker element to show."); }

                const overlayMapElem = document.getElementById('overlay-map');
                overlayMapElem.classList.add('overlay-map-fullscreen');
                overlayMap.resize();
                const bounds = new maptilersdk.LngLatBounds();
                bounds.extend(guessedLngLat);
                bounds.extend(actualLngLat);
                setTimeout(() => {
                    overlayMap.fitBounds(bounds, { padding: 50, duration: 1000, essential: true });
                }, 300);

                placeCustomRealLocationPinOnOverlay(actualLngLat);
                updateLineBetweenPins();
                if (overlayMap.getLayer('line-layer')) {
                    overlayMap.setLayoutProperty('line-layer', 'visibility', 'visible');
                    lineLayerVisible = true;
                }

                roundScoreDisplay.textContent = `Round Score: ${scoreResult.score} points`;
                totalScoreDisplay.textContent = `Total Score: ${totalScore} points`;
                roundScoreDisplay.style.display = 'block';
                totalScoreDisplay.style.display = 'block';

                let nextButton = document.getElementById('next-round-btn');
                if (!nextButton) {
                    nextButton = document.createElement('button');
                    nextButton.textContent = 'Next Round';
                    nextButton.id = 'next-round-btn';
                    const mapsContainer = document.querySelector('.maps-container');
                    mapsContainer.appendChild(nextButton);
                    nextButton.addEventListener('click', () => {
                        overlayMapElem.classList.remove('overlay-map-fullscreen');
                        overlayMap.flyTo({ center: initialCenter, zoom: initialZoom, essential: true, duration: 500 });
                        if (realLocationPinElement) { realLocationPinElement.remove(); realLocationPinElement = null; }
                        if (guessPinElement) { guessPinElement.remove(); guessPinElement = null; }
                        userGuessLngLat = null;
                        if (overlayMap.getLayer('line-layer')) {
                            overlayMap.setLayoutProperty('line-layer', 'visibility', 'none');
                            lineLayerVisible = false;
                        }
                        roundScoreDisplay.style.display = 'none';
                        totalScoreDisplay.style.display = 'none';
                        nextButton.remove();
                        setTimeout(() => { if(overlayMap) overlayMap.resize(); }, 500); // Added check for overlayMap
                        roundCount++;
                        document.getElementById('round-count').textContent = `Round: ${roundCount}`;
                        findRandomCityAndSpot();
                    });
                }
                submitGuessBtn.disabled = true;
                newLocationBtn.disabled = true;
            });
        }

        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', async () => {
            document.getElementById('login-btn').addEventListener('click', startOAuthFlow);
            document.getElementById('register-btn').addEventListener('click', startOAuthFlow); // Register can also start the same flow
            document.getElementById('logout-btn').addEventListener('click', appLogout);

            // Handle OAuth callback
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('code') && urlParams.has('state')) {
                const success = await handleOAuthCallback();
                if (success) {
                    isAuthenticated = true;
                    // Clean URL - remove OAuth parameters
                    window.history.replaceState({}, document.title, window.location.pathname);
                } else {
                    isAuthenticated = false;
                    // Error already alerted in handleOAuthCallback
                }
            } else {
                // Regular page load, check if already logged in via stored token
                isAuthenticated = await ensureValidToken();
            }
            updateAuthUI(); // This will show/hide game content and init if authenticated
        });
    </script>
</body>
</html>
