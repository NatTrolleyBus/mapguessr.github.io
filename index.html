<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr - Live Session Game</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f4f7f6;
        }
        header {
            background-color: #0cc0df;
            padding: 20px;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h1 {
            color: #444;
            margin-top: 0;
            text-align: center;
        }
        main {
            padding: 20px;
            max-width: 1980px;
            margin: 20px auto;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
        }
        section {
            margin-bottom: 30px;
        }
        
        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            color: white;
            z-index: 1000;
        }
        .connection-status.connected { background-color: #28a745; } /* Green */
        .connection-status.disconnected { background-color: #dc3545; } /* Red */
        .connection-status.connecting { background-color: #ffc107; } /* Yellow */

        /* Notifications */
        .notification-container {
            position: fixed;
            top: 50px;
            right: 10px;
            z-index: 1001;
            width: 300px;
        }
        .notification {
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        .notification.error { border-color: #dc3545; color: #dc3545; }
        .notification.info { border-color: #007bff; color: #007bff; }
        .notification.success { border-color: #28a745; color: #28a745; }

        /* Forms and Buttons */
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"],
        input[type="number"],
        button {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            box-sizing: border-box; /* Include padding in width */
            margin-bottom: 10px;
            font-size: 1em;
        }
        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            color: #666;
        }

        /* Session Display */
        #session-display {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 8px;
            display: none; /* Hidden until a session is active */
        }
        #session-display h2 {
            margin-top: 0;
            color: #007bff;
        }
        #session-id-display {
            font-weight: bold;
            color: #333;
        }

        /* Game Screen */
        #game-screen {
            display: none; /* Hidden until game starts */
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            background-color: #fff;
            margin-top: 20px;
        }
        #game-screen h2 {
            margin-top: 0;
            color: #007bff;
        }

        /* Map Container */
        .map-container {
            position: relative;
            width: 100%;
            height: 400px; /* Adjust height as needed */
            background-color: #e0e0e0;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
        }
        #map, #overlay-map {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
        #overlay-map {
            z-index: 2; /* Ensure overlay is above base map */
            pointer-events: none; /* Initially allow clicks to pass through */
            opacity: 0; /* Initially hidden */
            transition: opacity 0.5s ease-in-out;
        }
        #overlay-map.active {
            pointer-events: all; /* Enable clicks when active */
            opacity: 1; /* Show when active */
        }

        /* Pin elements */
        .guess-pin, .real-location-pin {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid white;
            background-color: #007bff; /* Blue for guess */
            cursor: grab;
            transform: translate(-50%, -50%); /* Center the pin */
            z-index: 3;
        }
        .real-location-pin {
            background-color: #28a745; /* Green for real location */
        }

        /* Line between pins */
        .line-between-pins {
            position: absolute;
            height: 2px;
            background-color: #000;
            transform-origin: 0% 50%;
            z-index: 2;
        }

        /* Game Status Bar */
        .game-status-bar {
            background-color: #e9f5ff; /* Light blue */
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1em;
            color: #0056b3;
            font-weight: bold;
        }

        /* Battle Royale Status Bar */
        .battle-royale-status-bar {
            background-color: #f0f8ff; /* Lighter blue background */
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .battle-royale-status-bar .status-item {
            text-align: center;
        }

        .battle-royale-status-bar .status-value {
            font-size: 2.2em; /* Larger font for key numbers */
            color: #0056b3; /* Darker blue for emphasis */
            font-weight: bold;
            display: block; /* Ensures value is on its own line */
        }

        /* Waiting for Others UI */
        #waiting-for-others-message {
            background-color: #fff3cd; /* Light yellow background */
            color: #856404; /* Dark yellow text */
            border: 1px solid #ffeeba;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1em;
            display: none; /* Hidden by default */
        }

        /* Live Player List / Leaderboard */
        #live-player-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 5px;
            background-color: #fff;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 5px;
            background-color: #f0f0f0;
            border-left: 5px solid #007bff;
            border-radius: 5px;
        }
        .player-item.you {
            background-color: #e6ffe6;
            border-left-color: #28a745; /* Green for current player */
            font-weight: bold;
        }
        .player-item.left {
            border-left-color: #ffc107; /* Orange for left players */
            background-color: #fff5e0;
            opacity: 0.8;
            text-decoration: line-through;
            font-style: italic;
        }
        .player-item.kicked {
            border-left-color: #dc3545; /* Red for kicked players */
            background-color: #ffe6e6;
            opacity: 0.6;
            text-decoration: line-through;
            font-style: italic;
        }
        /* Eliminated status for Battle Royale */
        .player-item.eliminated {
            border-left-color: #6c757d; /* Grey border */
            background-color: #e9ecef; /* Light grey background */
            opacity: 0.7;
            text-decoration: line-through;
            font-style: italic;
        }
        .player-item .rank {
            font-weight: bold;
            margin-right: 10px;
            min-width: 25px; /* Ensure space for rank number */
            text-align: right;
        }
        .player-item .name {
            flex-grow: 1;
        }
        .player-item .score {
            font-weight: bold;
            min-width: 60px; /* Ensure space for score */
            text-align: right;
        }
        .player-item .status {
            font-size: 0.9em;
            color: #666;
            margin-left: 10px;
            min-width: 70px;
            text-align: right;
        }
        .player-item.first {
            background-color: #fff2e0; /* Golden hue */
            border-left-color: #ffcc00;
        }


        /* Leaderboard */
        #leaderboard {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 8px;
            display: none; /* Hidden until game ends */
            margin-top: 20px;
        }
        #leaderboard h2 {
            margin-top: 0;
            color: #007bff;
            text-align: center;
        }
        #leaderboard-list .leaderboard-item {
            /* Inherits player-item styles, customize if needed */
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connection-status">Connecting...</div>
    <div class="notification-container" id="notification-container"></div>

    <header>
        <h1>Map Guessr - Live Session Game</h1>
    </header>

    <main>
        <section id="create-join-session">
            <h2>Join or Create Session</h2>
            <div class="form-group">
                <label for="player-name">Your Name:</label>
                <input type="text" id="player-name" placeholder="Enter your name" required />
            </div>
            <div class="form-group">
                <label for="session-id-input">Session ID (optional):</label>
                <input type="text" id="session-id-input" placeholder="Enter existing session ID" />
            </div>
            <button id="create-session-btn">Create New Session</button>
            <button id="join-session-btn">Join Session</button>
        </section>

        <section id="session-display">
            <h2>Session: <span id="session-id-display"></span></h2>
            <div class="waiting-room" id="waiting-room">
                <h3>Waiting for players...</h3>
                <p>Share this Session ID with your friends!</p>
                <button id="copy-session-id-btn">Copy Session ID</button>
                <button id="start-game-btn">Start Game</button>
            </div>

            <div id="game-screen">
                <div class="game-status-bar" id="game-status-bar"></div>

                <div class="battle-royale-status-bar">
                    <div class="status-item">
                        <span class="status-value" id="players-remaining">--</span>
                        <span>Players Remaining</span>
                    </div>
                    <div class="status-item">
                        <span class="status-value" id="time-remaining">--:--</span>
                        <span>Time Left</span>
                    </div>
                    <div class="status-item">
                        <span class="status-value" id="current-round-display">--</span>
                        <span>Round</span>
                    </div>
                </div>

                <div id="waiting-for-others-message">
                    Waiting for other players to submit their guesses...
                </div>

                <div class="map-container" id="map-container">
                    <div id="map"></div>
                    <div id="overlay-map"></div>
                    <div id="guess-pin" class="guess-pin" style="display: none;"></div>
                    <div id="real-location-pin" class="real-location-pin" style="display: none;"></div>
                    <div id="line-between-pins" class="line-between-pins" style="display: none;"></div>
                </div>

                <div class="form-group">
                    <button id="submit-guess-btn">Submit Guess</button>
                </div>
                <div class="form-group">
                    <p>Current Location: <span id="location-text">Loading map...</span></p>
                </div>
            </div>

            <section id="live-players-section">
                <h3>üèÜ Live Leaderboard</h3>
                <div id="live-player-list">
                    </div>
            </section>
        </section>

        <section id="leaderboard">
            <h2>Final Leaderboard</h2>
            <div id="leaderboard-list">
                </div>
            <button id="new-game-btn">Start New Game</button>
        </section>
    </main>

    <script>
        maptilersdk.config.apiKey = 'YOUR_MAPTILER_API_KEY'; // Replace with your MapTiler API Key

        const API_BASE_URL = 'https://game-session-worker.games-6cb.workers.dev/api';
        const WS_BASE_URL = 'wss://game-session-worker.games-6cb.workers.dev/ws';

        let playerName = '';
        let sessionId = '';
        let gameWebSocket;
        let map;
        let overlayMap;
        let userGuessLngLat = null;
        let actualLocationCoords = null;
        let guessPinElement;
        let realLocationPinElement;
        let lineBetweenPinsElement;
        let sessionData = {}; // Cache for current session data
        let hasSubmittedGuess = false; // Track if current player has submitted for the round

        const DOM = {}; // Object to cache DOM elements

        // Cache DOM elements for efficiency
        function cacheDOMElements() {
            DOM.connectionStatus = document.getElementById('connection-status');
            DOM.notificationContainer = document.getElementById('notification-container');
            DOM.playerNameInput = document.getElementById('player-name');
            DOM.sessionIdInput = document.getElementById('session-id-input');
            DOM.createSessionBtn = document.getElementById('create-session-btn');
            DOM.joinSessionBtn = document.getElementById('join-session-btn');
            DOM.createJoinSessionSection = document.getElementById('create-join-session');
            DOM.sessionDisplay = document.getElementById('session-display');
            DOM.sessionIdDisplay = document.getElementById('session-id-display');
            DOM.waitingRoom = document.getElementById('waiting-room');
            DOM.copySessionIdBtn = document.getElementById('copy-session-id-btn');
            DOM.startGameBtn = document.getElementById('start-game-btn');
            DOM.gameScreen = document.getElementById('game-screen');
            DOM.gameStatusBar = document.getElementById('game-status-bar');
            DOM.mapElement = document.getElementById('map');
            DOM.overlayMapElement = document.getElementById('overlay-map');
            DOM.guessPin = document.getElementById('guess-pin');
            DOM.realLocationPin = document.getElementById('real-location-pin');
            DOM.lineBetweenPins = document.getElementById('line-between-pins');
            DOM.submitGuessBtn = document.getElementById('submit-guess-btn');
            DOM.locationText = document.getElementById('location-text');
            DOM.livePlayerList = document.getElementById('live-player-list');
            DOM.leaderboardSection = document.getElementById('leaderboard');
            DOM.leaderboardList = document.getElementById('leaderboard-list');
            DOM.newGameBtn = document.getElementById('new-game-btn');

            // Battle Royale UI elements
            DOM.playersRemaining = document.getElementById('players-remaining');
            DOM.timeRemaining = document.getElementById('time-remaining');
            DOM.currentRoundDisplay = document.getElementById('current-round-display');
            DOM.waitingForOthersMessage = document.getElementById('waiting-for-others-message');
            DOM.mapContainer = document.getElementById('map-container');
        }

        // --- WebSocket Handling ---
        class GameWebSocket {
            constructor(url, onOpen, onMessage, onClose, onError) {
                this.ws = null;
                this.url = url;
                this.onOpen = onOpen;
                this.onMessage = onMessage;
                this.onClose = onClose;
                this.onError = onError;
                this.connect();
            }

            connect() {
                updateConnectionStatus('connecting');
                this.ws = new WebSocket(this.url);
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    updateConnectionStatus('connected');
                    if (this.onOpen) this.onOpen();
                };
                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    console.log('WebSocket message received:', message);
                    if (this.onMessage) this.onMessage(message);
                };
                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateConnectionStatus('disconnected');
                    if (this.onClose) this.onClose();
                    // If disconnected, try to reconnect after a delay, or show a reconnect button
                    showNotification('Disconnected from session. Attempting to reconnect...', 'error', 0);
                    setTimeout(() => this.connect(), 5000); // Attempt to reconnect after 5 seconds
                };
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('disconnected');
                    if (this.onError) this.onError(error);
                    showNotification('WebSocket error. Check console for details.', 'error');
                };
            }

            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                } else {
                    console.warn('WebSocket not open. Message not sent:', data);
                    showNotification('Connection not ready. Please try again.', 'error');
                }
            }

            close() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        function updateConnectionStatus(status) {
            const statusElement = DOM.connectionStatus;
            statusElement.className = `connection-status ${status}`;
            statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            DOM.notificationContainer.appendChild(notification);

            void notification.offsetWidth; // Trigger reflow
            notification.classList.add('show');

            if (duration > 0) {
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.addEventListener('transitionend', () => notification.remove());
                }, duration);
            } else {
                // Persistent notification if duration is 0
            }
        }

        // --- Session and Game Logic ---
        async function createSession() {
            playerName = DOM.playerNameInput.value.trim();
            if (!playerName) {
                showNotification('Please enter your name.', 'error');
                return;
            }
            localStorage.setItem('playerName', playerName); // Save name

            try {
                const response = await fetch(`${API_BASE_URL}/create-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerName })
                });
                const data = await response.json();
                if (response.ok) {
                    sessionId = data.sessionId;
                    localStorage.setItem('sessionId', sessionId); // Save session ID
                    localStorage.setItem('playerId', data.playerId); // Save player ID
                    showNotification(`Session created! ID: ${sessionId}`, 'success');
                    connectToWebSocket(sessionId, playerName);
                    displaySessionControls();
                } else {
                    throw new Error(data.error || 'Failed to create session');
                }
            } catch (error) {
                console.error('Error creating session:', error);
                showNotification(`Error creating session: ${error.message}`, 'error');
            }
        }

        async function joinSession() {
            playerName = DOM.playerNameInput.value.trim();
            sessionId = DOM.sessionIdInput.value.trim();
            if (!playerName || !sessionId) {
                showNotification('Please enter your name and session ID.', 'error');
                return;
            }
            localStorage.setItem('playerName', playerName); // Save name
            localStorage.setItem('sessionId', sessionId); // Save session ID

            try {
                const response = await fetch(`${API_BASE_URL}/join-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId, playerName })
                });
                const data = await response.json();
                if (response.ok) {
                    localStorage.setItem('playerId', data.playerId); // Save player ID
                    showNotification(`Joined session: ${sessionId}`, 'success');
                    connectToWebSocket(sessionId, playerName);
                    displaySessionControls();
                } else {
                    throw new Error(data.error || 'Failed to join session');
                }
            } catch (error) {
                console.error('Error joining session:', error);
                showNotification(`Error joining session: ${error.message}`, 'error');
            }
        }

        function connectToWebSocket(sId, pName) {
            if (gameWebSocket) {
                gameWebSocket.close(); // Close existing connection if any
            }
            const wsUrl = `${WS_BASE_URL}?sessionId=${sId}&playerName=${pName}&playerId=${getPlayerId()}`;
            gameWebSocket = new GameWebSocket(
                wsUrl,
                () => { /* onOpen, no specific action here */ },
                handleWebSocketMessage,
                () => { /* onClose, no specific action here */ },
                () => { /* onError, handled by class */ }
            );
        }

        function displaySessionControls() {
            DOM.createJoinSessionSection.style.display = 'none';
            DOM.sessionDisplay.style.display = 'block';
            DOM.sessionIdDisplay.textContent = sessionId;
        }

        function startGame() {
            gameWebSocket.send({ type: 'start_game' });
        }

        function copySessionId() {
            navigator.clipboard.writeText(sessionId)
                .then(() => showNotification('Session ID copied to clipboard!', 'success'))
                .catch(err => showNotification('Failed to copy session ID.', 'error'));
        }

        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'session_update':
                    sessionData = message.data;
                    handleSessionUpdate(sessionData);
                    break;
                case 'player_kicked':
                    // This event from server means a player was kicked by server-side logic (e.g. host kick)
                    showNotification(`${message.playerName} was kicked!`, 'info');
                    if (sessionData && sessionData.players) {
                        const kickedPlayer = sessionData.players.find(p => p.id === message.playerId);
                        if (kickedPlayer) {
                            kickedPlayer.status = 'kicked';
                        }
                    }
                    updateLivePlayersList();
                    // If the current player was kicked by the server
                    if (message.playerId === getPlayerId()) {
                        disableGameInteraction(true);
                        showNotification("You have been disconnected from the session!", 'error', 0);
                        // Optionally close WebSocket here, but `onclose` handler will trigger reconnect
                    }
                    break;
                case 'game_start':
                    showNotification('Game started!', 'success');
                    showGameScreen();
                    resetGameUI();
                    break;
                case 'new_round':
                    showNotification(`Round ${message.data.roundNumber} started! Guess the location!`, 'info');
                    sessionData.roundNumber = message.data.roundNumber; // Update round number
                    resetGameUI();
                    updateGameStatus(`Round ${message.data.roundNumber} - Guess the location!`);
                    DOM.currentRoundDisplay.textContent = sessionData.roundNumber;
                    break;
                case 'round_end':
                    showNotification('Round ended! Calculating scores...', 'info');
                    updateGameStatus('Round ended!');
                    hideOverlayMap();
                    hasSubmittedGuess = true; // Mark that current player has submitted their guess
                    DOM.waitingForOthersMessage.style.display = 'none'; // Hide if previously shown
                    disableGameInteraction(true); // Disable interaction until next round or game end

                    // Display real location and score for the round
                    actualLocationCoords = message.data.actualLocation;
                    if (actualLocationCoords) {
                        displayRealLocationPin(actualLocationCoords);
                    }
                    // Update scores in sessionData from server-provided roundScores
                    if (message.data.roundScores) {
                        sessionData.players.forEach(player => {
                            if (message.data.roundScores[player.id] !== undefined) {
                                player.score = (player.score || 0) + message.data.roundScores[player.id];
                            }
                        });
                    }

                    // This is where client-side battle royale kickout occurs
                    // Only perform kickout if the current player is still active
                    const currentPlayerStatus = sessionData.players.find(p => p.id === getPlayerId())?.status;
                    if (currentPlayerStatus === 'active') {
                        performBattleRoyaleClientKickout();
                    }

                    updateLivePlayersList(); // Refresh leaderboard after scores and potential kickouts
                    break;
                case 'game_end':
                    showNotification('Game ended! Final scores...', 'success');
                    updateGameStatus('Game Over!');
                    hideGameScreen();
                    showFinalLeaderboard(message.data.finalScores); // Show final leaderboard
                    break;
                case 'error':
                    showNotification(`Error: ${message.message}`, 'error');
                    break;
                case 'kickout_countdown': // If server provides countdown info (not directly used for client-side kickout logic)
                    if (message.data.timeLeft !== undefined) {
                        updateBattleRoyaleUI(null, message.data.timeLeft);
                    }
                    break;
                // No explicit 'player_eliminated' case needed from server, as client calculates its own eliminations
            }
        }

        function handleSessionUpdate(data) {
            DOM.sessionIdDisplay.textContent = data.sessionId;
            if (data.status === 'waiting') {
                DOM.waitingRoom.style.display = 'block';
                DOM.startGameBtn.style.display = data.isHost ? 'block' : 'none';
                DOM.gameScreen.style.display = 'none';
                DOM.leaderboardSection.style.display = 'none';
                DOM.waitingForOthersMessage.style.display = 'none'; // Ensure hidden
            } else if (data.status === 'in-game') {
                showGameScreen();
                DOM.waitingRoom.style.display = 'none';
                DOM.leaderboardSection.style.display = 'none';
                updateGameStatus(`Round ${data.roundNumber || '--'} - Guess the location!`);
                DOM.currentRoundDisplay.textContent = data.roundNumber || '--';
                // Reset hasSubmittedGuess for new round
                hasSubmittedGuess = false;
                disableGameInteraction(false); // Enable interaction for active players
            } else if (data.status === 'finished') {
                hideGameScreen();
                DOM.waitingRoom.style.display = 'none';
                showFinalLeaderboard(data.finalScores);
            }
            updateLivePlayersList();
        }

        function updateGameStatus(message) {
            DOM.gameStatusBar.textContent = message;
        }

        function updateBattleRoyaleUI(playersLeft, timeLeft) {
            if (playersLeft !== null && DOM.playersRemaining) DOM.playersRemaining.textContent = playersLeft;
            if (timeLeft !== null && DOM.timeRemaining) {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                DOM.timeRemaining.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else if (DOM.timeRemaining) {
                DOM.timeRemaining.textContent = '--:--'; // Clear if no time provided
            }
            if (sessionData.roundNumber !== undefined && DOM.currentRoundDisplay) {
                 DOM.currentRoundDisplay.textContent = sessionData.roundNumber;
            }
        }

        function updateLivePlayersList() {
            if (!sessionData || !sessionData.players) return;

            let html = '';
            const playerId = getPlayerId();

            // Filter out 'left' or 'kicked' players who are truly out of the game
            const playablePlayers = sessionData.players.filter(p => p.status === 'active' || p.status === 'eliminated');

            // Sort players for live leaderboard: active first, then by score descending, then eliminated
            const sortedPlayers = [...playablePlayers].sort((a, b) => {
                // Prioritize active players
                if (a.status === 'active' && b.status !== 'active') return -1;
                if (b.status === 'active' && a.status !== 'active') return 1;

                // For players with same status (e.g., both active or both eliminated), sort by score
                if (b.score !== a.score) {
                    return b.score - a.score; // Higher score first
                }

                return 0; // Maintain original order if scores are same
            });

            sortedPlayers.forEach((player, index) => {
                const isCurrentPlayer = player.id === playerId;
                let statusClass = player.status;
                if (isCurrentPlayer) statusClass += ' you';
                if (index === 0 && player.status === 'active') statusClass += ' first'; // Mark the current top active player

                html += `<div class="player-item ${statusClass}">
                    <div class="rank">${index + 1}.</div>
                    <div class="name"><strong>${player.name}</strong>${isCurrentPlayer ? ' (You)' : ''}</div>
                    <div class="score">${player.score || 0} pts</div>
                    <div class="status">${player.status === 'active' ? 'active' : (player.status === 'eliminated' ? 'eliminated' : player.status)}</div>
                </div>`;
            });
            DOM.livePlayerList.innerHTML = html;

            const activePlayersCount = sessionData.players.filter(p => p.status === 'active').length;
            updateBattleRoyaleUI(activePlayersCount, null); // Time left should come from server
        }

        function showGameScreen() {
            DOM.gameScreen.style.display = 'block';
            DOM.createJoinSessionSection.style.display = 'none';
            DOM.sessionDisplay.style.display = 'block';
            DOM.leaderboardSection.style.display = 'none';
            initializeMaps();
        }

        function hideGameScreen() {
            DOM.gameScreen.style.display = 'none';
        }

        function resetGameUI() {
            if (guessPinElement) guessPinElement.style.display = 'none';
            if (realLocationPinElement) realLocationPinElement.style.display = 'none';
            if (lineBetweenPinsElement) lineBetweenPinsElement.style.display = 'none';
            userGuessLngLat = null;
            actualLocationCoords = null;
            DOM.locationText.textContent = 'Guess the location!';
            DOM.submitGuessBtn.disabled = false; // Re-enable for new round
            showOverlayMap();
            hasSubmittedGuess = false; // Reset submission status for new round
            DOM.waitingForOthersMessage.style.display = 'none'; // Hide waiting message
            disableGameInteraction(false); // Ensure interaction is enabled for new round
        }

        function showFinalLeaderboard(finalScores) {
            DOM.leaderboardSection.style.display = 'block';
            let html = '';
            const sortedScores = Object.entries(finalScores)
                .map(([id, score]) => ({ id, score, name: sessionData.players.find(p => p.id === id)?.name || 'Unknown' }))
                .sort((a, b) => b.score - a.score);

            sortedScores.forEach((player, index) => {
                const isFirst = index === 0 ? 'first' : '';
                html += `<div class="player-item ${isFirst}">
                    <div class="rank">${index + 1}.</div>
                    <div class="name"><strong>${player.name}</strong></div>
                    <div class="score">${player.score} pts</div>
                    <div class="status"></div> </div>`;
            });
            DOM.leaderboardList.innerHTML = html;
        }

        function getPlayerId() {
            return localStorage.getItem('playerId');
        }

        function disableGameInteraction(isDisabled) {
            // Disable/enable map clicks
            if (overlayMap) {
                if (isDisabled) {
                    overlayMap.off('click', placeGuessPinHandler);
                    overlayMap.off('contextmenu', placeGuessPinHandler);
                    DOM.mapContainer.style.pointerEvents = 'none'; // Visually disable map area
                    DOM.mapContainer.style.opacity = '0.7';
                } else {
                    overlayMap.on('click', placeGuessPinHandler);
                    overlayMap.on('contextmenu', placeGuessPinHandler);
                    DOM.mapContainer.style.pointerEvents = 'auto';
                    DOM.mapContainer.style.opacity = '1';
                }
            }
            // Disable submit button
            DOM.submitGuessBtn.disabled = isDisabled;
        }

        // --- Map Handling ---
        function initializeMaps() {
            if (map) return; // Maps already initialized

            try {
                map = new maptilersdk.Map({
                    container: DOM.mapElement,
                    style: maptilersdk.MapStyle.STREETS,
                    center: [0, 0], // Default center
                    zoom: 1
                });

                overlayMap = new maptilersdk.Map({
                    container: DOM.overlayMapElement,
                    style: maptilersdk.MapStyle.STREETS,
                    center: [0, 0], // Default center
                    zoom: 1,
                    interactive: true
                });

                guessPinElement = DOM.guessPin;
                realLocationPinElement = DOM.realLocationPin;
                lineBetweenPinsElement = DOM.lineBetweenPins;

                overlayMap.on('load', () => {
                    // Handlers are attached/detached by disableGameInteraction
                    if (!hasSubmittedGuess) { // Only enable if not already submitted
                        disableGameInteraction(false);
                    } else {
                        disableGameInteraction(true);
                    }
                });

                // Handle overlay map transitions
                DOM.overlayMapElement.addEventListener('transitionend', () => {
                    if (overlayMap) {
                        overlayMap.resize();
                        if (guessPinElement && userGuessLngLat) updateGuessPinPositionHandler();
                        if (realLocationPinElement && actualLocationCoords) updateRealLocationPinPositionHandler();
                        updateLineBetweenPins();
                    }
                });

                DOM.submitGuessBtn.addEventListener('click', submitGuess);

                console.log('Maps initialized successfully');
                
            } catch (error) {
                console.error('Failed to initialize maps:', error);
                DOM.locationText.textContent = `Failed to load maps: ${error.message}`;
            }
        }

        function showOverlayMap() {
            DOM.overlayMapElement.classList.add('active');
        }

        function hideOverlayMap() {
            DOM.overlayMapElement.classList.remove('active');
        }

        function placeGuessPinHandler(e) {
            userGuessLngLat = e.lngLat;
            updateGuessPinPositionHandler();
            DOM.submitGuessBtn.disabled = false;
        }

        function updateGuessPinPositionHandler() {
            if (userGuessLngLat && guessPinElement) {
                const pixelCoords = overlayMap.project(userGuessLngLat);
                guessPinElement.style.left = `${pixelCoords.x}px`;
                guessPinElement.style.top = `${pixelCoords.y}px`;
                guessPinElement.style.display = 'block';
                updateLineBetweenPins();
            }
        }

        function displayRealLocationPin(lngLat) {
            actualLocationCoords = lngLat;
            updateRealLocationPinPositionHandler();
        }

        function updateRealLocationPinPositionHandler() {
            if (actualLocationCoords && realLocationPinElement) {
                const pixelCoords = map.project(actualLocationCoords);
                realLocationPinElement.style.left = `${pixelCoords.x}px`;
                realLocationPinElement.style.top = `${pixelCoords.y}px`;
                realLocationPinElement.style.display = 'block';
                updateLineBetweenPins();
            }
        }

        function updateLineBetweenPins() {
            if (userGuessLngLat && actualLocationCoords && lineBetweenPinsElement) {
                const guessPixel = overlayMap.project(userGuessLngLat);
                const realPixel = map.project(actualLocationCoords); // Use base map for real location

                const dx = realPixel.x - guessPixel.x;
                const dy = realPixel.y - guessPixel.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                lineBetweenPinsElement.style.width = `${distance}px`;
                lineBetweenPinsElement.style.transform = `translate(${guessPixel.x}px, ${guessPixel.y}px) rotate(${angle}deg)`;
                lineBetweenPinsElement.style.display = 'block';
            } else {
                lineBetweenPinsElement.style.display = 'none';
            }
        }

        function submitGuess() {
            if (!userGuessLngLat) {
                showNotification('Please place your guess pin on the map.', 'error');
                return;
            }
            gameWebSocket.send({
                type: 'submit_guess',
                guess: {
                    lng: userGuessLngLat.lng,
                    lat: userGuessLngLat.lat
                }
            });
            DOM.submitGuessBtn.disabled = true; // Disable after submitting
            hasSubmittedGuess = true;
            DOM.waitingForOthersMessage.style.display = 'block'; // Show waiting message
            disableGameInteraction(true); // Disable interaction while waiting for others
        }

        // --- NEW: Client-side Battle Royale Kickout Logic ---
        function performBattleRoyaleClientKickout() {
            const activePlayers = sessionData.players.filter(p => p.status === 'active');
            
            if (activePlayers.length <= 1) {
                console.log("Battle Royale: Only one or zero active players remaining, game should end or no more kickouts needed.");
                // If only one player left, declare winner and end game
                if (activePlayers.length === 1) {
                    showNotification(`${activePlayers[0].name} is the last one standing!`, 'success', 5000);
                    // Trigger game_end logic if not already handled by server
                    gameWebSocket.send({ type: 'game_end_client_trigger', finalScores: sessionData.players.reduce((acc, p) => ({ ...acc, [p.id]: p.score }), {}) });
                }
                return;
            }

            // Sort players by score in ascending order for elimination
            // Lower scores are eliminated first
            const playersForElimination = [...activePlayers].sort((a, b) => a.score - b.score);

            // Calculate how many players to kick: half the active players, rounded down.
            // This rule (Math.floor(N/2)) handles both even and odd cases as per your clarification:
            // - If 4 players: floor(4/2) = 2 players kicked.
            // - If 3 players: floor(3/2) = 1 player kicked (matching "in the case of 3, kick 1").
            const numPlayersToKick = Math.floor(playersForElimination.length / 2);

            if (numPlayersToKick === 0) {
                console.log("Battle Royale: No players to kick based on current rules or too few players to kick.");
                return;
            }

            const kickedPlayers = playersForElimination.slice(0, numPlayersToKick);

            kickedPlayers.forEach(player => {
                const originalPlayer = sessionData.players.find(p => p.id === player.id);
                if (originalPlayer) {
                    originalPlayer.status = 'eliminated';
                    showNotification(`${originalPlayer.name} has been eliminated!`, 'info');
                    // If the eliminated player is *this* client
                    if (originalPlayer.id === getPlayerId()) {
                        showNotification("You have been eliminated!", 'error', 5000);
                        disableGameInteraction(true); // Permanently disable interaction for this client
                        // Do NOT close WebSocket unless the server is also going to close it,
                        // otherwise this client just silently disappears from server's perspective.
                        // The player's UI is now just a spectator/leaderboard view.
                    }
                }
            });

            // After potential eliminations, check if only one active player remains
            const remainingActivePlayers = sessionData.players.filter(p => p.status === 'active').length;
            if (remainingActivePlayers <= 1) {
                console.log("Battle Royale: Game over, one or zero active players remaining after kickout.");
                const winner = sessionData.players.find(p => p.status === 'active');
                if (winner) {
                    showNotification(`${winner.name} wins the Battle Royale!`, 'success', 5000);
                } else {
                     showNotification("No winner found or all players eliminated!", 'info', 5000);
                }
                gameWebSocket.send({ type: 'game_end_client_trigger', finalScores: sessionData.players.reduce((acc, p) => ({ ...acc, [p.id]: p.score }), {}) });
            }
            
            updateLivePlayersList(); // Re-render leaderboard to show eliminated players
            console.log(`Battle Royale: Kicked ${kickedPlayers.length} players.`);
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements();
            updateConnectionStatus('disconnected');

            // Retrieve player name and session ID/player ID from localStorage
            playerName = localStorage.getItem('playerName') || '';
            sessionId = localStorage.getItem('sessionId') || '';
            const playerId = localStorage.getItem('playerId') || '';

            DOM.playerNameInput.value = playerName;
            DOM.sessionIdInput.value = sessionId;

            // If a session ID and player ID are found, attempt to auto-reconnect
            if (sessionId && playerId) {
                console.log(`Attempting to reconnect to session ${sessionId} as ${playerName} (ID: ${playerId})...`);
                showNotification('Attempting to reconnect to session...', 'info', 0); // Persistent until connected/error
                connectToWebSocket(sessionId, playerName);
                displaySessionControls(); // Show session UI immediately
            }

            // Event Listeners
            DOM.createSessionBtn.addEventListener('click', createSession);
            DOM.joinSessionBtn.addEventListener('click', joinSession);
            DOM.startGameBtn.addEventListener('click', startGame);
            DOM.copySessionIdBtn.addEventListener('click', copySessionId);
            DOM.newGameBtn.addEventListener('click', () => {
                // Clear local storage for a fresh start
                localStorage.removeItem('playerName');
                localStorage.removeItem('sessionId');
                localStorage.removeItem('playerId');
                location.reload(); // Simple reload for fresh start
            });

            // Store player name on input change
            DOM.playerNameInput.addEventListener('change', (e) => {
                playerName = e.target.value;
                localStorage.setItem('playerName', playerName);
            });
        });

        // --- Cleanup on page unload ---
        window.addEventListener('beforeunload', () => {
            if (gameWebSocket) {
                gameWebSocket.close();
            }
        });
    </script>
</body>
</html>
