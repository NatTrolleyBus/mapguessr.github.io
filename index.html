<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr - Live Session Game</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        /* --- Additions & Modifications --- */
        /* General Body & Font (Minor Polish) */
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f4f7f6;
        }
        header {
            background-color: #0cc0df;
            padding: 20px;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #fff;
            margin-top: 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        header p {
            color: #e0f7fa;
        }
        main {
            padding: 20px;
            max-width: 1980px;
            margin: 0 auto;
        }
        section {
            margin-bottom: 30px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        section h2 {
            border-bottom: 2px solid #0cc0df;
            padding-bottom: 10px;
            margin-top: 0;
            color: #333;
        }
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        .loading-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #0cc0df;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* View Transitions */
        .view-container {
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
            /* display: none; */
        }
        .view-container.visible {
            opacity: 1;
        }
        /* Connection Status (Slight position adjustment for notification) */
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .status-connected { background: #d4edda; color: #155724; }
        .status-connecting { background: #fff3cd; color: #856404; }
        .status-disconnected { background: #f8d7da; color: #721c24; }
        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        /* Notification Polish */
        .notification {
            position: fixed;
            top: 60px;
            right: 10px;
            padding: 12px 18px;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            color: #0c5460;
            font-size: 14px;
            z-index: 1000;
            max-width: 320px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.15);
            transform: translateX(110%);
            opacity: 0;
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
            /* display: none; */
            pointer-events: none;
        }
        .notification.show {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
        }
        /* Notification types - ensure these specific styles take precedence */
        .notification.error {
            background: #f8d7da !important;
            border-color: #f5c6cb !important;
            color: #721c24 !important;
        }
        .notification.success {
            background: #d4edda !important;
            border-color: #c3e6cb !important;
            color: #155724 !important;
        }
        .notification.info {
            background: #d1ecf1 !important;
            border-color: #bee5eb !important;
            color: #0c5460 !important;
        }
        /* Session Management Styles Polish */
        .session-container {
            max-width: 600px;
            margin: 30px auto;
            padding: 30px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background-color: #ffffff;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .session-form input {
            padding: 12px;
            margin: 10px;
            font-size: 1.1em;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: calc(100% - 44px);
            max-width: 300px;
            box-sizing: border-box;
        }
        .session-form button,
        .submit-btn,
        .new-location-btn,
        .start-game-btn,
        .next-round-btn {
            padding: 12px 30px;
            font-size: 1.1em;
            background-color: #0cc0df;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .session-form button:hover,
        .submit-btn:hover,
        .new-location-btn:hover,
        .start-game-btn:hover,
        .next-round-btn:hover {
            background-color: #0aa8c4;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .session-form button:active,
        .submit-btn:active,
        .new-location-btn:active,
        .start-game-btn:active,
        .next-round-btn:active {
            transform: scale(0.98);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .session-form button:disabled,
        .submit-btn:disabled,
        .new-location-btn:disabled,
        .start-game-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        .session-info { background-color: #e8f4f8; padding: 20px; border-radius: 5px; margin: 20px 0; }
        .waiting-message { background-color: #fff3cd; color: #856404; padding: 15px; border-radius: 5px; margin: 20px 0; border: 1px solid #ffeaa7; }
        .error-message { background-color: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; margin: 20px 0; border: 1px solid #f5c6cb; }
        .success-message { background-color: #d4edda; color: #155724; padding: 15px; border-radius: 5px; margin: 20px 0; border: 1px solid #c3e6cb; }
        /* Live Player List Polish */
        .live-players {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: left;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 4px 0;
            background-color: white;
            border-radius: 4px;
            border-left: 5px solid #28a745;
            transition: background-color 0.2s;
        }
        .player-item:hover {
            background-color: #f0f0f0;
        }
        .player-item.you { border-left-color: #007cba; background-color: #e6f3ff; }
        .player-item.left { border-left-color: #ffc107; background-color: #fff3cd; }
        .player-item.kicked { border-left-color: #dc3545; background-color: #f8d7da; }
        /* Game Styles Polish */
        .maps-container {
            position: relative;
            height: 700px;
            width: 100%;
            margin-bottom: 20px;
            overflow: hidden;
        }
        #maptiler-map {
            position: relative;
            width: 100%;
            height: 100%;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
            background-color: #eaeaea;
        }
        #overlay-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 400px;
            height: 250px;
            border: 2px solid #555;
            border-radius: 5px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 10;
            transition: all 0.4s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out;
        }
        #overlay-map:hover:not(.overlay-map-fullscreen) {
            width: 420px;
            height: 270px;
        }
        .overlay-map-fullscreen {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 100 !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }
        .submit-container { text-align: center; margin-bottom: 30px; }
        /* Game Progress List Styling */
        #game-container ul {
            list-style-type: none;
            padding-left: 0;
        }
        #game-container ul li {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 0.95em;
            color: #333;
        }
        #game-container ul li strong {
            color: #007cba;
        }
        /* Live Leaderboard Polish */
        .leaderboard {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .leaderboard table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .leaderboard th, .leaderboard td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        .leaderboard th { background-color: #0cc0df; color: white; }
        .leaderboard tr:nth-child(even) { background-color: #f2f2f2; }
        .leaderboard tr:hover { background-color: #e9ecef; }
        .leaderboard tr.current-player { background-color: #fff3cd !important; font-weight: bold; }
        /* Footer Polish */
        footer {
            background-color: #0cc0df;
            padding: 15px;
            text-align: center;
            border-radius: 5px 5px 0 0;
            font-size: 0.9em;
            margin-top: 40px;
            color: white;
        }
        /* Pin Animations */
        .guess-pin, .real-location-pin {
            position: absolute;
            width: 24px;
            height: 36px;
            background-size: contain;
            background-repeat: no-repeat;
            /* Base transform for centering pin point at LngLat */
            transform: translate3d(-50%, -100%, 0);
            pointer-events: none;

            /* Animation properties */
            opacity: 0;
            transform: translate3d(-50%, -100%, 0) scale(0.3) translateY(-40px);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease-out;
        }
        .guess-pin.visible, .real-location-pin.visible {
            opacity: 1;
            transform: translate3d(-50%, -100%, 0) scale(1) translateY(0);
        }
        .guess-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%23e53e3e" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            z-index: 101;
        }
        .real-location-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%2328a745" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>');
            z-index: 102;
        }
        #next-round-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            font-size: 1.1em;
            background-color: #0cc0df;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 110;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        #next-round-btn:hover {
            background-color: #0aa8c4;
        }
        /* REMOVE Corner Score Displays */
        #round-score-display, #total-score-display {
            display: none !important;
        }
        /* Game Status Bar Polish */
        .game-status-bar {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
            color: #555;
        }
        .status-value {
            font-weight: bold;
            font-size: 16px;
            color: #007cba;
            margin-bottom: 3px;
        }
        /* Ensure maptiler controls remain hidden */
        .maptiler-ctrl-group,
        .maptiler-ctrl,
        .maplibregl-ctrl-group,
        .maplibregl-ctrl {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="loading-overlay" class="loading-overlay"><div class="spinner"></div></div>
    <div id="connectionStatus" class="connection-status status-connecting">
        <span class="live-indicator"></span>
        <span id="statusText">Not Connected</span>
    </div>
    
    <div id="notification" class="notification"></div>
    
    <header>
        <h1>Map Guessr - Live Session Game</h1>
        <p>Real-time Connected Multiplayer Experience</p>
    </header>
   
    <main>
        <div id="session-join" class="session-container view-container visible">
            <h2>Join Live Game Session</h2>
            <p>Enter your session code and player name to join the live game.</p>
            <div class="session-form">
                <input type="text" id="session-code" placeholder="Session Code" maxlength="10">
            
            <br>
                <input type="text" id="player-name" placeholder="Your Name" maxlength="30">
                <br>
                <button onclick="joinSession()" id="join-button">Join Live Session</button>
            </div>
            <div id="join-message"></div>
        </div>

   
        <div id="session-waiting" class="session-container view-container" style="display: none;">
            <h2>üî¥ Live Session Joined!</h2>
            <div id="session-info" class="session-info"></div>
            
            <div class="live-players">
                <h4>üë• Live Players</h4>
               
                <div id="players-list"></div>
            </div>
            
            <div class="waiting-message">
                <h3>‚è≥ Waiting for game to start...</h3>
                <p><strong>Live Status:</strong> Connected and waiting for administrator instructions</p>
              
                <p>You'll be automatically notified when the game becomes available!</p>
            </div>
            
            <div class="game-status-bar">
                <div class="status-item">
                    <span class="status-value" id="live-status">waiting</span>
           
                    <span>Status</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="live-players-count">0</span>
                    <span>Players</span>
             
                </div>
                <div class="status-item">
                    <span class="status-value" id="live-connections">0</span>
                    <span>Connected</span>
                </div>
            </div>
       
      
            <button class="start-game-btn" onclick="startGame()" id="start-button" style="display: none;">üéÆ Start Playing</button>
            <div id="wait-message"></div>
        </div>

        <div id="game-container" class="game-container view-container">
            <section>
                <h2>üéØ Live Game in Progress</h2>
      
                <div id="game-status" class="game-status-bar"></div>
                <div class="maps-container">
                    <div id="maptiler-map"></div>
                    <div id="overlay-map"></div>
                </div>
          
                <div class="submit-container">
                    <button class="submit-btn" id="submit-guess">Submit Guess</button>
                </div>
            </section>
            
            <section>
               
                <h2>üìä Game Progress</h2>
                <ul>
                    <li id="location-text">Waiting for location...</li>
                    <li id="guessed-coords">Make your guess on the overlay map...</li>
                    <li id="submit-status">Place your guess on the overlay map...</li>
 
                    <li id="points-score">Points: - |
                    Total: 0 points</li>
                    <li id="round-count">Round: 1 |
                    Game: 1</li>
                </ul>
            </section>

            <div id="leaderboard-container">
                <div class="leaderboard">
                    <h3>üèÜ Live Leaderboard</h3>
                
                    <div id="leaderboard-content">
                        <p>Waiting for scores...</p>
                    </div>
                </div>
            </div>
        </div>
    </main>
    <footer>
  
        <p>Live WebSocket-Based Map Guessr Game</p>
    </footer>

    <div id="round-score-display"></div>
    <div id="total-score-display"></div>

    <script>
        // --- Configuration ---
        const API_BASE_URL = 'https://game-session-worker.games-6cb.workers.dev';
        const INITIAL_ZOOM_LEVEL = 15;
        const OVERLAY_INITIAL_CENTER = [0, 0];
        const OVERLAY_INITIAL_ZOOM = -0.5;
        const MAX_SCORE_PER_ROUND = 5000;
        const PERFECT_SCORE_THRESHOLD_METERS = 100;
        const SCORE_DECAY_FACTOR = 2000000;
        // --- Session State Variables ---
        let sessionCode = null;
        let playerName = null;
        let playerId = null;
        let sessionData = null;
        let currentRound = 1;
        let currentGame = 1;
        let gameWebSocket = null;
        
        // --- Game State Variables ---
        let mainMap = null;
        let overlayMap = null;
        let currentSdkMarker = null;
        let userGuessLngLat = null;
        let guessPinElement = null;
        let realLocationPinElement = null;
        let actualLocationCoords = null;
        let totalScore = 0;
        let gameInProgress = false;

        // --- DOM Elements Cache ---
        const DOM = {};
        function cacheDOMElements() {
            DOM.loadingOverlay = document.getElementById('loading-overlay');
            DOM.connectionStatus = document.getElementById('connectionStatus');
            DOM.statusText = document.getElementById('statusText');
            DOM.sessionCodeInput = document.getElementById('session-code');
            DOM.playerNameInput = document.getElementById('player-name');
            DOM.sessionJoin = document.getElementById('session-join');
            DOM.sessionWaiting = document.getElementById('session-waiting');
            DOM.gameContainer = document.getElementById('game-container');
            DOM.sessionInfo = document.getElementById('session-info');
            DOM.waitMessage = document.getElementById('wait-message');
            DOM.joinMessage = document.getElementById('join-message');
            DOM.startButton = document.getElementById('start-button');
            DOM.locationText = document.getElementById('location-text');
            DOM.guessedCoordsText = document.getElementById('guessed-coords');
            DOM.submitStatusText = document.getElementById('submit-status');
            DOM.pointsScoreText = document.getElementById('points-score');
            DOM.roundCountText = document.getElementById('round-count');
            DOM.submitGuessBtn = document.getElementById('submit-guess');
            DOM.overlayMapElement = document.getElementById('overlay-map');
            // DOM.roundScoreDisplay = document.getElementById('round-score-display');
            // REMOVED
            // DOM.totalScoreDisplay = document.getElementById('total-score-display');
            // REMOVED
            DOM.mapsContainer = document.querySelector('.maps-container');
            DOM.leaderboardContainer = document.getElementById('leaderboard-container');
            DOM.leaderboardContent = document.getElementById('leaderboard-content');
            DOM.gameStatus = document.getElementById('game-status');
            DOM.playersListElement = document.getElementById('players-list');
            DOM.liveStatus = document.getElementById('live-status');
            DOM.livePlayersCount = document.getElementById('live-players-count');
            DOM.liveConnections = document.getElementById('live-connections');
            DOM.joinButton = document.getElementById('join-button');
            DOM.notificationElement = document.getElementById('notification');
        }

        // --- Loading Overlay Management ---
        function showLoading() {
            if (DOM.loadingOverlay) DOM.loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            if (DOM.loadingOverlay) DOM.loadingOverlay.classList.remove('visible');
        }

        // --- WebSocket Connection ---
        class GameWebSocket {
            constructor(url, sessionCode) {
                this.url = url;
                this.sessionCode = sessionCode;
                this.ws = null;
                this.connect();
                this.pingInterval = setInterval(() => this.send({ type: 'ping' }), 25000); // Ping every 25s
            }

            connect() {
                if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
                    console.log('WebSocket already connected or connecting.');
                    return;
                }
                updateConnectionStatus('connecting');
                try {
                    this.ws = new WebSocket(`${this.url}?sessionCode=${this.sessionCode}&playerId=${playerId}`);

                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        updateConnectionStatus('connected');
                    };

                    this.ws.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        console.log('Received:', message);
                        this.handleMessage(message);
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket disconnected:', event);
                        updateConnectionStatus('disconnected');
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        updateConnectionStatus('disconnected');
                        this.scheduleReconnect();
                    };
                } catch (error) {
                    console.error('Error creating WebSocket:', error);
                    updateConnectionStatus('disconnected');
                    this.scheduleReconnect();
                }
            }

            send(message) {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                } else {
                    console.warn('WebSocket not connected, message not sent:', message);
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'session_update':
                        handleSessionUpdate(message.data);
                        if (message.event) { handleSessionEvent(message.event); }
                        break;
                    case 'join_success':
                        showNotification('Successfully joined the game!', 'success');
                        // showSessionWaiting();
                        // Moved to handleSessionUpdate
                        // hideLoading(); // Moved to handleSessionUpdate
                        break;
                    case 'score_success':
                        showNotification(`Score posted! Total: ${message.totalScore}`, 'success');
                        break;
                    case 'session_deleted':
                        showNotification('Session was deleted by admin', 'error');
                        resetToJoinScreen();
                        break;
                    case 'error':
                        showNotification(`Error: ${message.message}`, 'error');
                        break;
                    case 'pong':
                        // Server responded to ping
                        break;
                    case 'connected':
                        console.log('WebSocket:', message.message);
                        break;
                    default:
                        console.log('Unknown message type:', message.type, message);
                }
            }

            scheduleReconnect() {
                if (!sessionCode) return;
                // Don't reconnect if we've explicitly reset to join screen
                if (!gameWebSocket || gameWebSocket.ws?.readyState === WebSocket.CLOSED) {
                    console.log('Attempting to reconnect in 3 seconds...');
                    setTimeout(() => {
                        if (sessionCode) { // Ensure session code still exists
                            this.connect();
                        }
                    }, 3000);
                }
            }
        }

        function handleSessionUpdate(data) {
            sessionData = data;
            console.log('Session data updated:', sessionData);
            totalScore = sessionData.players.find(p => p.id === playerId)?.totalScore || 0;
            updateLiveSessionInfo();
            updateLivePlayersList();
            updateGameStatusDisplay();

            // Transition based on game status
            if (sessionData.status === 'active') {
                showSessionWaiting(); // Ensure waiting screen is shown initially
                checkGameAvailability(); // Determine if "Start Playing" button should show
            } else if (sessionData.status === 'waiting') {
                showSessionWaiting();
            } else if (sessionData.status === 'ended') {
                showSessionWaiting();
                showMessage('wait-message', 'Game has ended. Thank you for playing!', 'info');
                DOM.startButton.style.display = 'none';
            }
            hideLoading();
        }

        function handleSessionEvent(event) {
            let message = '';
            switch (event.type) {
                case 'player_joined':
                    message = `${event.playerName} joined the session!`;
                    break;
                case 'player_left':
                    message = `${event.playerName} left the session.`;
                    break;
                case 'player_kicked':
                    message = `${event.playerName} was kicked from the session.`;
                    if (event.playerId === playerId) {
                        showNotification('You were kicked from the session.', 'error');
                        resetToJoinScreen();
                        return;
                    }
                    break;
                case 'admin_status':
                    message = `Admin status updated: ${event.status}`;
                    break;
                case 'score_updated':
                    message = `Score update: ${event.score} points`;
                    break;
                case 'round_toggled':
                    message = `Round ${event.roundId} ${event.open ? 'opened' : 'closed'}`;
                    checkGameAvailability(); // Re-check availability
                    break;
                case 'game_toggled':
                    message = `Game ${event.gameId} ${event.open ? 'opened' : 'closed'}`;
                    checkGameAvailability(); // Re-check availability
                    break;
                case 'session_started':
                    message = 'Session started - cities generated';
                    break;
                case 'cities_approved':
                    message = 'Cities approved - game is now active';
                    checkGameAvailability();
                    break;
                case 'session_ended':
                    message = `Session ended: ${event.reason || 'No reason given'}`;
                    break;
            }
            if (message) { showNotification(message); }
        }

        function updateLiveSessionInfo() {
            if (!sessionData) return;
            DOM.sessionInfo.innerHTML = `
                <h3>Session: ${sessionData.joinCode}</h3>
                <p><strong>Player:</strong> ${playerName}</p>
                <p><strong>Game Type:</strong> ${sessionData.gameType}</p>
                <p><strong>Status:</strong> ${sessionData.status}</p>
            `;
            DOM.liveStatus.textContent = sessionData.status;
            DOM.livePlayersCount.textContent = sessionData.players ? sessionData.players.length : 0;
            DOM.liveConnections.textContent = sessionData.connectionCount || 0;
        }

        function updateLivePlayersList() {
            if (!sessionData || !sessionData.players) return;
            let html = '';
            sessionData.players.forEach(player => {
                const isCurrentPlayer = player.id === playerId;
                let statusClass = player.status === 'active' ? '' : player.status === 'left' ? 'left' : player.status === 'kicked' ? 'kicked' : '';
                html += `
                    <div class="player-item ${isCurrentPlayer ? 'you' : ''} ${statusClass}">
                        <span>${player.name} ${isCurrentPlayer ? '(You)' : ''}</span>
                        <span>Total Score: ${player.totalScore !== undefined ? player.totalScore : 'N/A'}</span>
                    </div>
                `;
            });
            DOM.playersListElement.innerHTML = html;
        }

        function updateGameStatusDisplay() {
            DOM.gameStatus.innerHTML = `
                <div class="status-item">
                    <span class="status-value">Round ${currentRound}</span>
                    <span>Current Round</span>
                </div>
                <div class="status-item">
                    <span class="status-value">Game ${currentGame}</span>
                    <span>Current Game</span>
                </div>
                <div class="status-item">
                    <span class="status-value">${totalScore}</span>
                    <span>Your Score</span>
                </div>
                <div class="status-item">
                    <span class="status-value">${sessionCode}</span>
                    <span>Session</span>
                </div>
            `;
        }

        function checkGameAvailability() {
            if (!sessionData || sessionData.status !== 'active') {
                DOM.startButton.style.display = 'none';
                return;
            }

            const openRound = sessionData.rounds.find(r => r.open);
            if (openRound) {
                const openGame = openRound.games.find(g => g.open);
                if (openGame) {
                    DOM.startButton.style.display = 'block';
                    showMessage('wait-message', 'Game is active! You can start playing.', 'success');
                } else {
                    DOM.startButton.style.display = 'none';
                    showMessage('wait-message', 'Game is active but no rounds are currently open. Waiting for administrator...', 'waiting');
                }
            } else if (sessionData.status === 'ended') {
                showMessage('wait-message', 'Game has ended. Thank you for playing!', 'info');
                DOM.startButton.style.display = 'none';
            } else {
                DOM.startButton.style.display = 'none';
                showMessage('wait-message', `Game status: ${sessionData.status}. Waiting for game to start...`, 'waiting');
            }
        }

        // --- Connection Status Management ---
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const textElement = document.getElementById('statusText');
            statusElement.className = 'connection-status';
            switch (status) {
                case 'connected':
                    statusElement.classList.add('status-connected');
                    textElement.innerHTML = '<span class="live-indicator" style="background: #28a745;"></span>Live';
                    break;
                case 'connecting':
                    statusElement.classList.add('status-connecting');
                    textElement.innerHTML = '<span class="live-indicator" style="background: #ffc107;"></span>Connecting...';
                    break;
                case 'disconnected':
                    statusElement.classList.add('status-disconnected');
                    textElement.innerHTML = 'üî¥ Disconnected';
                    break;
            }
        }

        function showNotification(message, type = 'info') {
            if (!message || !DOM.notificationElement) return;
            // Use cached DOM.notificationElement
            DOM.notificationElement.textContent = message;

            // Reset classes
            DOM.notificationElement.className = 'notification';
            DOM.notificationElement.classList.add(type); // Add error, success, or info class

            DOM.notificationElement.classList.add('show');

            setTimeout(() => {
                DOM.notificationElement.classList.remove('show');
            }, 5000); // Notification disappears after 5 seconds
        }

        // --- Session Actions ---
        async function joinSession() {
            sessionCode = DOM.sessionCodeInput.value.trim().toUpperCase();
            playerName = DOM.playerNameInput.value.trim();

            if (!sessionCode || !playerName) {
                showMessage('join-message', 'Please enter both session code and your name.', 'error');
                return;
            }

            showLoading();
            DOM.joinButton.disabled = true;
            DOM.joinButton.textContent = 'Joining...';

            try {
                // First, register player and get playerId
                const registerResponse = await fetch(`${API_BASE_URL}/api/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: playerName, sessionCode: sessionCode })
                });

                if (!registerResponse.ok) {
                    const errorData = await registerResponse.json();
                    throw new Error(errorData.error || `HTTP ${registerResponse.status}`);
                }

                const registerData = await registerResponse.json();
                playerId = registerData.playerId;
                sessionCode = registerData.sessionCode; // Confirm session code from server

                // Initialize WebSocket after getting playerId
                gameWebSocket = new GameWebSocket('wss://game-session-worker.games-6cb.workers.dev/websocket', sessionCode);

                // Give WebSocket a moment to connect and receive initial session update
                setTimeout(() => {
                    if (gameWebSocket.ws?.readyState === WebSocket.OPEN) {
                        // showSessionWaiting(); // This will be called after successful join or update
                        // hideLoading will be called after session update or if join fails
                    } else {
                        showMessage('join-message', 'Failed to connect to session. Please try again.', 'error');
                        DOM.joinButton.disabled = false;
                        DOM.joinButton.textContent = 'Join Live Session';
                        hideLoading();
                        resetToJoinScreen(); // Go back if connection fails
                    }
                }, 1500); // Increased delay slightly for WS to open
            } catch (error) {
                showMessage('join-message', `Failed to join session: ${error.message}`, 'error');
                DOM.joinButton.disabled = false;
                DOM.joinButton.textContent = 'Join Live Session';
                hideLoading();
            }
        }

        function showSessionWaiting() {
            // DOM.sessionJoin.style.display = 'none';
            // DOM.sessionWaiting.style.display = 'block';
            if (DOM.sessionJoin) DOM.sessionJoin.classList.remove('visible');
            setTimeout(() => {
                if (DOM.sessionJoin) DOM.sessionJoin.style.display = 'none';
                if (DOM.sessionWaiting) {
                    DOM.sessionWaiting.style.display = 'block'; // Ensure the new view is ready for transition
                    requestAnimationFrame(() => {
                        DOM.sessionWaiting.classList.add('visible');
                    });
                }
            }, 400); // Match CSS transition duration
        }

        function resetToJoinScreen() {
            if (gameWebSocket) {
                gameWebSocket.close();
                gameWebSocket = null;
            }
            sessionCode = null;
            playerName = null;
            playerId = null;
            sessionData = null;
            gameInProgress = false;
            currentRound = 1;
            currentGame = 1;
            totalScore = 0;

            if (DOM.gameContainer) DOM.gameContainer.classList.remove('visible');
            if (DOM.sessionWaiting) DOM.sessionWaiting.classList.remove('visible');

            setTimeout(() => {
                if (DOM.gameContainer) DOM.gameContainer.style.display = 'none';
                if (DOM.sessionWaiting) DOM.sessionWaiting.style.display = 'none';
                if (DOM.sessionJoin) {
                    DOM.sessionJoin.style.display = 'block';
                    requestAnimationFrame(() => {
                        DOM.sessionJoin.classList.add('visible');
                    });
                }
                DOM.sessionCodeInput.value = '';
                DOM.playerNameInput.value = '';
                DOM.joinMessage.innerHTML = '';
                DOM.joinButton.disabled = false;
                DOM.joinButton.textContent = 'Join Live Session';
                updateConnectionStatus('disconnected'); // Reset status visually
                hideLoading(); // Ensure loading is hidden
            }, 400); // Match CSS transition duration
        }

        // --- Game Actions ---
        async function startGame() {
            if (!gameWebSocket || gameWebSocket.ws.readyState !== WebSocket.OPEN) {
                showNotification('WebSocket is not connected. Please try rejoining the session.', 'error');
                return;
            }
            if (!sessionData) {
                showNotification('Session data not loaded. Please wait.', 'error');
                return;
            }

            const openRound = sessionData.rounds.find(r => r.open);
            if (!openRound) {
                showNotification('No active rounds found. Please wait for administrator to open a round.', 'error');
                return;
            }

            const openGame = openRound.games.find(g => g.open);
            if (!openGame) {
                showNotification('No games are currently open in this round. Please wait for administrator.', 'error');
                return;
            }
            currentRound = openRound.id;
            currentGame = openGame.id;
            gameInProgress = true;

            if(DOM.sessionWaiting) DOM.sessionWaiting.classList.remove('visible');
            showLoading(); // Show loader while maps initialize

            setTimeout(() => {
                if(DOM.sessionWaiting) DOM.sessionWaiting.style.display = 'none';
                if(DOM.gameContainer) {
                    DOM.gameContainer.style.display = 'block';
                    requestAnimationFrame(() => {
                        DOM.gameContainer.classList.add('visible');
                    });
                }
                
                initializeMaps().then(() => {
                    loadGameLocation(); // This will hideLoading after location is set
                }).catch(() => {
                    hideLoading(); // Hide loading on map init error
                });
            }, 400);
        }

        async function loadGameLocation() {
            try {
                DOM.locationText.textContent = 'Loading location...';
                showLoading(); // ADDED - show general loader
                // Get city for current round/game using REST API
                const response = await fetch(`${API_BASE_URL}/api/cities?round=${currentRound}&game=${currentGame}`, {
                    headers: { 'X-Session-Code': sessionCode }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const cityData = await response.json();
                const cityName = cityData.city;
                DOM.locationText.textContent = `Finding a spot in ${cityName}...`;
                // Geocode the city using our proxy
                const geocodingResponse = await fetch(`${API_BASE_URL}/api/geocode?city=${encodeURIComponent(cityName)}`, {
                    headers: { 'X-Session-Code': sessionCode }
                });
                const geocodingData = await geocodingResponse.json();

                if (!geocodingData.features || geocodingData.features.length === 0) {
                    throw new Error('City not found or unable to geocode.');
                }

                // Pick a random feature (e.g., first one) and its bbox for randomness
                const feature = geocodingData.features[0];
                const bounds = feature.bbox; // [minLng, minLat, maxLng, maxLat]

                if (!bounds || bounds.length !== 4) {
                    throw new Error('City bounds not found.');
                }

                actualLocationCoords = getRandomCoordinateInBounds(bounds);
                console.log('Actual location chosen:', actualLocationCoords);
                DOM.locationText.textContent = `Round ${currentRound} - Guess the location near ${cityName}!`;
                DOM.guessedCoordsText.textContent = 'Click on the overlay map to place your guess.';
                DOM.submitStatusText.textContent = 'Place your guess on the overlay map...';
                DOM.submitGuessBtn.disabled = false; // Enable submit button

                // Adjust main map view to a zoomed-out view of the world
                if (mainMap) {
                    mainMap.setCenter([0, 0]);
                    mainMap.setZoom(1);
                }

                // Reset overlay map and remove old pins/lines
                if (overlayMap) {
                    overlayMap.setCenter(OVERLAY_INITIAL_CENTER);
                    overlayMap.setZoom(OVERLAY_INITIAL_ZOOM);
                    if (guessPinElement) guessPinElement.remove();
                    if (realLocationPinElement) realLocationPinElement.remove();
                    const lineSource = overlayMap.getSource('line-source');
                    if (lineSource) {
                        lineSource.setData({ 'type': 'Feature', 'geometry': { 'type': 'LineString', 'coordinates': [] } });
                    }
                    setOverlayMapFullscreen(false); // Ensure overlay map is not fullscreen
                }
            } catch (error) {
                console.error('Error loading game location:', error);
                DOM.locationText.textContent = `Failed to load location: ${error.message}`;
                DOM.submitGuessBtn.disabled = true;
                showNotification(`Failed to load game location: ${error.message}`, 'error');
            } finally {
                hideLoading(); // Hide loading indicator after location is set or error
                updateGameStatusDisplay(); // Update game status bar
                updateLeaderboard(); // Update leaderboard with current scores
                DOM.pointsScoreText.innerHTML = `Points: - | Total: ${totalScore} points`;
                DOM.roundCountText.textContent = `Round: ${currentRound} | Game: ${currentGame}`;
            }
        }

        async function submitGuess() {
            console.log("Submit button clicked.");
            const guess = convertToLngLat(userGuessLngLat);
            const actual = convertToLngLat(actualLocationCoords);

            if (!guess) {
                DOM.submitStatusText.textContent = 'Please make a guess by clicking on the overlay map.';
                return;
            }
            if (!actual) {
                DOM.submitStatusText.textContent = 'Error: No actual location set for scoring.';
                return;
            }
            showLoading(); // Show loading while processing

            const scoreResult = calculateGeoGuessrScore(actual.lat, actual.lng, guess.lat, guess.lng);
            if (isNaN(scoreResult.score) || isNaN(scoreResult.distance)) {
                DOM.submitStatusText.textContent = 'Error: Score calculation failed.';
                hideLoading();
                return;
            }

            totalScore += scoreResult.score;
            DOM.pointsScoreText.innerHTML = `<strong>Round Score:</strong> ${scoreResult.score} points <em>(${(scoreResult.distance / 1000).toFixed(2)} km)</em> <br> <strong>Total Score:</strong> ${totalScore} points`;
            // Modified for clarity
            DOM.submitStatusText.textContent = `Guess submitted! You scored ${scoreResult.score} points.`;
            DOM.submitGuessBtn.disabled = true; // Disable submit button after guessing

            // Display real location and line
            placeRealLocationPin(actualLocationCoords);
            updateLineBetweenPins();

            // Set overlay map to fullscreen and fit both pins
            setOverlayMapFullscreen(true, { guess: userGuessLngLat, actual: actualLocationCoords });

            // Post score to the server
            try {
                const response = await fetch(`${API_BASE_URL}/api/scores`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-Code': sessionCode,
                        'X-Player-Id': playerId
                    },
                    body: JSON.stringify({
                        round: currentRound,
                        game: currentGame,
                        score: scoreResult.score,
                        distance: scoreResult.distance,
                        guess: [guess.lng, guess.lat],
                        actual: [actual.lng, actual.lat]
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const scoreResponse = await response.json();
                console.log('Score posted successfully:', scoreResponse);
                updateLeaderboard(); // Refresh leaderboard after score submission
                checkNextGameAvailability(); // Determine if "Next Round" button should show
            } catch (error) {
                console.error('Failed to post score:', error);
                showNotification(`Failed to post score: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function checkNextGameAvailability() {
            if (!sessionData) {
                showWaitingForNextGame('No session data available.');
                return;
            }

            // Find current round
            const currentRoundData = sessionData.rounds.find(r => r.id === currentRound);
            if (!currentRoundData) {
                showWaitingForNextGame('Current round not found. Please wait for administrator instructions.');
                return;
            }
            // Look for next game in current round
            const nextGameInRound = currentRoundData.games.find(g => g.id > currentGame && g.open);
            if (nextGameInRound) {
                showContinueButton(() => proceedToNextGame(nextGameInRound.id, currentRound));
            } else {
                // Look for next round
                const nextRound = sessionData.rounds.find(r => r.id > currentRound && r.open);
                if (nextRound && nextRound.games.some(g => g.open)) {
                    const firstGameInRound = nextRound.games.find(g => g.open);
                    showContinueButton(() => proceedToNextGame(firstGameInRound.id, nextRound.id));
                } else {
                    showWaitingForNextGame('No more games are currently available. Waiting for administrator...');
                }
            }
        }

        function showContinueButton(callback) {
            DOM.submitStatusText.innerHTML = `Guess submitted!
                <button onclick="continueToNext()" style="margin-left: 10px; padding: 8px 16px; background: #0cc0df; color: white; border: none; border-radius: 4px; cursor: pointer;"> Continue to Next Game </button>
            `;
            window.continueToNext = callback;
        }

        function showWaitingForNextGame(message) {
            DOM.submitStatusText.textContent = message;
        }

        function proceedToNextGame(gameId, roundId) {
            currentRound = roundId;
            currentGame = gameId;
            userGuessLngLat = null; // Reset guess
            actualLocationCoords = null; // Reset actual location
            DOM.submitGuessBtn.disabled = true; // Disable until new location loaded
            loadGameLocation();
            hideScoresPopup(); // Hide the previous score display
        }

        async function updateLeaderboard() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/leaderboard?sessionCode=${sessionCode}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const leaderboardData = await response.json();
                renderLeaderboard(leaderboardData.leaderboard);
            } catch (error) {
                console.error('Failed to fetch leaderboard:', error);
                DOM.leaderboardContent.innerHTML = '<p>Failed to load leaderboard.</p>';
            }
        }

        function renderLeaderboard(players) {
            if (!players || players.length === 0) {
                DOM.leaderboardContent.innerHTML = '<p>No scores yet.</p>';
                return;
            }

            players.sort((a, b) => b.totalScore - a.totalScore); // Sort by total score descending

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Total Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            players.forEach((player, index) => {
                const isCurrentPlayer = player.playerId === playerId;
                html += `
                    <tr class="${isCurrentPlayer ? 'current-player' : ''}">
                        <td>${index + 1}</td>
                        <td>${player.playerName} ${isCurrentPlayer ? '(You)' : ''}</td>
                        <td>${player.totalScore}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;
            DOM.leaderboardContent.innerHTML = html;
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            const className = type === 'error' ? 'error-message' : type === 'success' ?
                'success-message' :
                type === 'waiting' ? 'waiting-message' :
                'session-info';
            element.innerHTML = `<div class="${className}">${message}</div>`;
        }

        function getRandomCoordinateInBounds(bounds) {
            const [minLng, minLat, maxLng, maxLat] = bounds;
            const buffer = 0.001;
            const bufferedMinLng = minLng + (maxLng - minLng) * buffer;
            const bufferedMinLat = minLat + (maxLat - minLat) * buffer;
            const bufferedMaxLng = maxLng - (maxLng - minLng) * buffer;
            const bufferedMaxLat = maxLat - (maxLat - minLat) * buffer;
            const randomLng = bufferedMinLng + (bufferedMaxLng - bufferedMinLng) * Math.random();
            const randomLat = bufferedMinLat + (bufferedMaxLat - bufferedMinLat) * Math.random();
            return [randomLng, randomLat];
        }

        function calculateDistanceInMeters(lat1, lon1, lat2, lon2) {
            if ([lat1, lon1, lat2, lon2].some(coord => typeof coord !== 'number')) {
                console.error("Invalid input types for calculateDistanceInMeters:", lat1, lon1, lat2, lon2);
                return NaN;
            }
            const R = 6371e3; // metres
            const œÜ1 = lat1 * Math.PI / 180; // œÜ, Œª in radians
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            const d = R * c; // in metres
            return d;
        }

        function calculateGeoGuessrScore(actualLat, actualLng, guessLat, guessLng) {
            const distance = calculateDistanceInMeters(actualLat, actualLng, guessLat, guessLng);
            if (isNaN(distance)) {
                return { distance: NaN, score: 0 };
            }

            let score;
            if (distance <= PERFECT_SCORE_THRESHOLD_METERS) {
                score = MAX_SCORE_PER_ROUND;
            } else {
                score = Math.round(MAX_SCORE_PER_ROUND * Math.exp(-distance / SCORE_DECAY_FACTOR));
            }
            score = Math.max(0, score); // Ensure score is not negative
            return { distance, score };
        }

        function convertToLngLat(lngLatInput) {
            if (lngLatInput instanceof maptilersdk.LngLat) {
                return lngLatInput;
            }
            if (Array.isArray(lngLatInput) && lngLatInput.length === 2 && typeof lngLatInput[0] === 'number' && typeof lngLatInput[1] === 'number') {
                return new maptilersdk.LngLat(lngLatInput[0], lngLatInput[1]);
            }
            console.error("convertToLngLat received invalid LngLat data:", lngLatInput);
            return null;
        }

        // --- Pin Management ---
        function createPinElement(className) {
            const element = document.createElement('div');
            element.className = className;
            return element;
        }

        function updatePinPosition(mapInstance, pinEl, lngLat) {
            if (!mapInstance || !pinEl || !lngLat) return;
            const validLngLat = convertToLngLat(lngLat);
            if (!validLngLat) {
                console.error("Invalid LngLat object for pin positioning:", lngLat);
                return;
            }
            const pixelCoords = mapInstance.project(validLngLat);
            pinEl.style.left = `${pixelCoords.x}px`;
            pinEl.style.top = `${pixelCoords.y}px`;
            pinEl.style.display = 'block';
        }

        function placeGuessPin(lngLat) {
            console.log('Attempting to place custom guess pin at LngLat:', lngLat);
            userGuessLngLat = convertToLngLat(lngLat);
            if (!userGuessLngLat) return;

            if (guessPinElement) guessPinElement.remove();
            guessPinElement = createPinElement('guess-pin');
            overlayMap.getCanvasContainer().appendChild(guessPinElement);
            updatePinPosition(overlayMap, guessPinElement, userGuessLngLat);
            
            // Trigger animation
            requestAnimationFrame(() => {
                // Use rAF for smoother start
                if (guessPinElement) guessPinElement.classList.add('visible');
            });
            DOM.guessedCoordsText.textContent = `Guessed: ${userGuessLngLat.lat.toFixed(4)}, ${userGuessLngLat.lng.toFixed(4)}`;
        }

        function placeRealLocationPin(lngLat) {
            console.log('Attempting to place real location pin at LngLat:', lngLat);
            if (realLocationPinElement) realLocationPinElement.remove();
            realLocationPinElement = createPinElement('real-location-pin');
            overlayMap.getCanvasContainer().appendChild(realLocationPinElement);
            updatePinPosition(overlayMap, realLocationPinElement, lngLat);

            // Trigger animation
            requestAnimationFrame(() => {
                if (realLocationPinElement) realLocationPinElement.classList.add('visible');
            });
        }

        function updateLineBetweenPins() {
            if (!overlayMap || !userGuessLngLat || !actualLocationCoords) return;

            const validUserGuess = convertToLngLat(userGuessLngLat);
            const validActualLocation = convertToLngLat(actualLocationCoords);

            if (!validUserGuess || !validActualLocation) {
                console.error("Invalid LngLat objects for drawing line:", userGuessLngLat, actualLocationCoords);
                return;
            }

            const lineGeoJSON = {
                'type': 'Feature',
                'geometry': {
                    'type': 'LineString',
                    'coordinates': [
                        [validUserGuess.lng, validUserGuess.lat],
                        [validActualLocation.lng, validActualLocation.lat]
                    ]
                }
            };
            const source = overlayMap.getSource('line-source');
            if (source) {
                source.setData(lineGeoJSON);
            }
        }

        function displayScoresPopup(roundScore, currentTotalScore) {
            DOM.roundScoreDisplay.textContent = `Round Score: ${roundScore} points`;
            DOM.totalScoreDisplay.textContent = `Total Score: ${currentTotalScore} points`;
            DOM.roundScoreDisplay.style.display = 'block';
            DOM.totalScoreDisplay.style.display = 'block';
        }

        function hideScoresPopup() {
            DOM.roundScoreDisplay.style.display = 'none';
            DOM.totalScoreDisplay.style.display = 'none';
        }

        function setOverlayMapFullscreen(isFullscreen, fitBoundsLocations = null) {
            if (isFullscreen) {
                DOM.overlayMapElement.classList.add('overlay-map-fullscreen');
                overlayMap.resize();
                if (fitBoundsLocations && fitBoundsLocations.guess && fitBoundsLocations.actual) {
                    const bounds = new maptilersdk.LngLatBounds();
                    bounds.extend(fitBoundsLocations.guess);
                    bounds.extend(fitBoundsLocations.actual);
                    overlayMap.fitBounds(bounds, {
                        padding: 100, // Padding around the bounds in pixels
                        duration: 1000 // Animation duration in milliseconds
                    });
                }
            } else {
                DOM.overlayMapElement.classList.remove('overlay-map-fullscreen');
                overlayMap.resize(); // Important to call resize after changing size
                overlayMap.setCenter(OVERLAY_INITIAL_CENTER);
                overlayMap.setZoom(OVERLAY_INITIAL_ZOOM);
            }
        }

        // --- Map Initialization ---
        async function initializeMaps() {
            try {
                // Initialize Main Map (World View)
                const mainMapStyle = maptilersdk.MapStyleV9.OUTDOOR; // Or your preferred style
                mainMap = new maptilersdk.Map({
                    container: 'maptiler-map',
                    style: mainMapStyle,
                    center: [0, 0],
                    zoom: 1,
                    interactive: false
                });

                // Initialize Overlay Map (Guessing Map)
                const overlayMapStyle = maptilersdk.MapStyleV9.STREETS; // Detailed map for guessing
                overlayMap = new maptilersdk.Map({
                    container: 'overlay-map',
                    style: overlayMapStyle,
                    center: OVERLAY_INITIAL_CENTER,
                    zoom: OVERLAY_INITIAL_ZOOM,
                    interactive: true
                });

                overlayMap.on('style.load', () => {
                    // Add line layer for showing distance
                    overlayMap.addSource('line-source', {
                        'type': 'geojson',
                        'data': {
                            'type': 'Feature',
                            'geometry': {
                                'type': 'LineString',
                                'coordinates': []
                            }
                        }
                    });
                    overlayMap.addLayer({
                        'id': 'line-layer',
                        'type': 'line',
                        'source': 'line-source',
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        'paint': {
                            'line-color': '#e53e3e',
                            'line-width': 4,
                            'line-dasharray': [1, 2] // Dashed line
                        }
                    });
                });

                overlayMap.on('click', (e) => {
                    if (!DOM.submitGuessBtn.disabled) { // Only allow placing guess if submit button is enabled
                        placeGuessPin(e.lngLat);
                        DOM.submitStatusText.textContent = 'Guess placed. Click Submit Guess when ready!';
                        // If actual location is already set (e.g., after loading first time without submitting)
                        // then we can update the line between pins immediately
                        if (actualLocationCoords) updateLineBetweenPins();
                    }
                });
                // Add submit button handler
                DOM.submitGuessBtn.addEventListener('click', submitGuess);
                console.log('Maps initialized successfully');
                
            } catch (error) {
                console.error('Failed to initialize maps:', error);
                DOM.locationText.textContent = `Failed to load maps: ${error.message}`;
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements();
            updateConnectionStatus('disconnected');
            // Set initial view states for opacity transition
            if (DOM.sessionJoin) DOM.sessionJoin.classList.add('visible'); // Already display:block
            if (DOM.sessionWaiting) DOM.sessionWaiting.style.opacity = '0'; // display:none in HTML
            if (DOM.gameContainer) DOM.gameContainer.style.opacity = '0'; // display:none via CSS

            hideLoading(); // Ensure loading is hidden on initial load
        });
        // --- Cleanup on page unload ---
        window.addEventListener('beforeunload', () => {
            if (gameWebSocket) {
                gameWebSocket.close();
            }
        });
    </script>
</body>
</html>
