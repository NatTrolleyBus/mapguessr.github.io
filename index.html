<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr - Live Session Game</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        /* --- Additions & Modifications --- */
        /* General Body & Font (Minor Polish) */
        body {
            font-family: Arial, sans-serif; /* [1] */
            line-height: 1.6; /* [2] */
            margin: 0; /* [2] */
            padding: 0; /* [2] */
            color: #333; /* [2] */
            background-color: #f4f7f6; /* Optional: Light background for the page */
        }
        header {
            background-color: #0cc0df; /* [2] */
            padding: 20px; /* [3] */
            border-radius: 0 0 5px 5px; /* [3] */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow for depth */
        }
        h1 {
            color: #fff; /* Brighter color for header text on dark background */
            margin-top: 0; /* [4] */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2); /* Slight text shadow */
        }
        header p {
            color: #e0f7fa; /* Lighter color for subheading */
        }
        main {
            padding: 20px; /* [4] */
            max-width: 1980px; /* [5] */
            margin: 0 auto; /* [5] */
        }
        section {
            margin-bottom: 30px; /* [6] */
            background-color: #fff; /* Card-like background for sections */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        section h2 {
            border-bottom: 2px solid #0cc0df;
            padding-bottom: 10px;
            margin-top: 0;
            color: #333;
        }
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        .loading-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #0cc0df;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* View Transitions */
        .view-container {
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
            /* display: none; /* Initial display is handled by inline style or existing CSS */
        }
        .view-container.visible {
            opacity: 1;
        }
        /* Connection Status (Slight position adjustment for notification) */
        .connection-status {
            position: fixed; /* [7] */
            top: 10px; /* [7] */
            right: 10px; /* [7] */
            padding: 8px 12px; /* [7] */
            border-radius: 20px; /* [7] */
            font-size: 12px; /* [7] */
            font-weight: bold; /* [7] */
            z-index: 1000; /* [8] */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* [8] */
        }
        .status-connected { background: #d4edda; color: #155724; /* [9] */ }
        .status-connecting { background: #fff3cd; color: #856404; /* [10] */ }
        .status-disconnected { background: #f8d7da; color: #721c24; /* [11] */ }
        .live-indicator {
            display: inline-block; /* [12] */
            width: 8px; /* [12] */
            height: 8px; /* [12] */
            border-radius: 50%; /* [12] */
            margin-right: 5px; /* [12] */
            animation: pulse 2s infinite; /* [13] */
        }
        @keyframes pulse { /* [14, 15, 16] */
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        /* Notification Polish */
        .notification {
            position: fixed; /* [17] */
            top: 60px; /* [17] */ /* Adjusted if connection status is on top */
            right: 10px; /* [17] */
            padding: 12px 18px; /* [18] */ /* Slightly more padding */
            border: 1px solid #bee5eb; /* [18] */
            border-radius: 6px; /* [18] */ /* Softer radius */
            color: #0c5460; /* [18] */
            font-size: 14px; /* [18] */
            z-index: 1000; /* [18] */
            max-width: 320px; /* [19] */ /* Slightly wider */
            box-shadow: 0 3px 8px rgba(0,0,0,0.15); /* [19] */ /* Enhanced shadow */
            transform: translateX(110%); /* Start off-screen to the right */
            opacity: 0;
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
            /* display: none; Will be controlled by JS via class */
            pointer-events: none; /* Initially not interactive */
        }
        .notification.show {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto; /* Interactive when shown */
        }
        /* Notification types - ensure these specific styles take precedence */
        .notification.error { /* Match JS types */
            background: #f8d7da !important; /* [184] */
            border-color: #f5c6cb !important; /* [184] */
            color: #721c24 !important; /* [184] */
        }
        .notification.success { /* Match JS types */
            background: #d4edda !important; /* [185] */
            border-color: #c3e6cb !important; /* [185] */
            color: #155724 !important; /* [185] */
        }
        .notification.info { /* Default, if needed */
            background: #d1ecf1 !important; /* [186] */
            border-color: #bee5eb !important; /* [186] */
            color: #0c5460 !important; /* [186] */
        }
        /* Session Management Styles Polish */
        .session-container {
            max-width: 600px; /* [20] */
            margin: 30px auto; /* [20] */ /* Reduced top margin */
            padding: 30px; /* [20] */
            border: 1px solid #ddd; /* [21] */
            border-radius: 10px; /* [21] */
            background-color: #ffffff; /* [21] */ /* Brighter background */
            text-align: center; /* [21] */
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .session-form input {
            padding: 12px; /* [23] */ /* More padding */
            margin: 10px; /* [23] */
            font-size: 1.1em; /* [24] */
            border: 1px solid #ccc; /* [24] */
            border-radius: 5px; /* [24] */
            width: calc(100% - 44px); /* [24] */ /* Adjust width for padding and border */
            max-width: 300px; /* Max width for inputs */
            box-sizing: border-box;
        }
        .session-form button,
        .submit-btn, 
        .new-location-btn, 
        .start-game-btn, 
        .next-round-btn { /* Grouping common button styles */
            padding: 12px 30px; /* [25, 53] */
            font-size: 1.1em; /* [25, 53] */
            background-color: #0cc0df; /* [25, 53] */
            color: white; /* [25, 53] */
            border: none; /* [25, 53] */
            border-radius: 5px; /* [25, 53] */
            cursor: pointer; /* [26, 54] */
            margin: 10px 5px; /* [26, 54] */
            transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out; /* [54] */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .session-form button:hover,
        .submit-btn:hover, 
        .new-location-btn:hover, 
        .start-game-btn:hover, 
        .next-round-btn:hover {
            background-color: #0aa8c4; /* [27, 55] */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .session-form button:active,
        .submit-btn:active, 
        .new-location-btn:active, 
        .start-game-btn:active, 
        .next-round-btn:active {
            transform: scale(0.98);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .session-form button:disabled,
        .submit-btn:disabled, 
        .new-location-btn:disabled, 
        .start-game-btn:disabled { /* [56] */
            background-color: #ccc; /* [28, 56] */
            cursor: not-allowed; /* [28, 56] */
            box-shadow: none;
        }
        .session-info { background-color: #e8f4f8; padding: 20px; border-radius: 5px; margin: 20px 0; /* [29] */ }
        .waiting-message { background-color: #fff3cd; color: #856404; padding: 15px; border-radius: 5px; margin: 20px 0; border: 1px solid #ffeaa7; /* [30, 31] */ }
        .error-message { background-color: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; margin: 20px 0; border: 1px solid #f5c6cb; /* [32, 33] */ }
        .success-message { background-color: #d4edda; color: #155724; padding: 15px; border-radius: 5px; margin: 20px 0; border: 1px solid #c3e6cb; /* [34, 35] */ }
        /* Live Player List Polish */
        .live-players {
            background-color: #f8f9fa; /* [36] */
            padding: 15px; /* [36] */
            border-radius: 5px; /* [36] */
            margin: 15px 0; /* [36] */
            text-align: left; /* [36] */
        }
        .player-item {
            display: flex; /* [37] */
            justify-content: space-between; /* [37] */
            align-items: center; /* [37] */
            padding: 10px; /* [38] */ /* More padding */
            margin: 4px 0; /* [38] */
            background-color: white; /* [38] */
            border-radius: 4px; /* [38] */ /* Softer radius */
            border-left: 5px solid #28a745; /* [38] */ /* Thicker border */
            transition: background-color 0.2s;
        }
        .player-item:hover {
            background-color: #f0f0f0;
        }
        .player-item.you { border-left-color: #007cba; background-color: #e6f3ff; /* [39] */ }
        .player-item.left { border-left-color: #ffc107; background-color: #fff3cd; /* [40] */ }
        .player-item.kicked { border-left-color: #dc3545; background-color: #f8d7da; /* [41] */ }
        /* Game Styles Polish */
        .maps-container {
            position: relative; /* [43] */
            height: 700px; /* [43] */ /* Adjusted height if needed */
            width: 100%; /* [43] */
            margin-bottom: 20px; /* [43] */
            overflow: hidden; /* [43] */
        }
        #maptiler-map {
            position: relative; /* [44] */
            width: 100%; /* [44] */
            height: 100%; /* [44] */
            border: 1px solid #ddd; /* [45] */
            border-radius: 5px; /* [45] */
            overflow: hidden; /* [45] */
            background-color: #eaeaea; /* [45] */
        }
        #overlay-map {
            position: absolute; /* [46] */
            bottom: 20px; /* [46] */
            right: 20px; /* [46] */
            width: 400px; /* [47] */ /* Adjusted default size */
            height: 250px; /* [47] */ /* Adjusted default size */
            border: 2px solid #555; /* [47] */
            border-radius: 5px; /* [47] */
            overflow: hidden; /* [47] */
            background-color: #fff; /* [47] */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* [48] */
            z-index: 10; /* [48] */
            transition: all 0.4s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out; /* [48] */
        }
        #overlay-map:hover:not(.overlay-map-fullscreen) {
            width: 420px; /* [49] */ /* Slightly larger on hover */
            height: 270px; /* [49] */
        }
        .overlay-map-fullscreen {
            position: absolute !important; /* [50] */
            top: 0 !important; /* [50] */
            left: 0 !important; /* [50] */
            width: 100% !important; /* [51] */
            height: 100% !important; /* [51] */
            z-index: 100 !important; /* [51] */
            border: none !important; /* [51] */
            border-radius: 0 !important; /* [51] */
            box-shadow: none !important; /* [51] */
        }
        .submit-container { text-align: center; margin-bottom: 30px; /* [52] */ }
        /* Game Progress List Styling */
        #game-container ul {
            list-style-type: none;
            padding-left: 0;
        }
        #game-container ul li {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 0.95em;
            color: #333;
        }
        #game-container ul li strong {
            color: #007cba;
        }
        /* Live Leaderboard Polish */
        .leaderboard {
            background-color: #f8f9fa; /* [57] */
            padding: 20px; /* [57] */
            border-radius: 5px; /* [57] */
            margin: 20px 0; /* [57] */
        }
        .leaderboard table { width: 100%; border-collapse: collapse; margin-top: 10px; /* [58] */ }
        .leaderboard th, .leaderboard td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; /* [59] */ } /* More padding */
        .leaderboard th { background-color: #0cc0df; color: white; /* [60] */ }
        .leaderboard tr:nth-child(even) { background-color: #f2f2f2; /* [61] */ }
        .leaderboard tr:hover { background-color: #e9ecef; }
        .leaderboard tr.current-player { background-color: #fff3cd !important; font-weight: bold; /* [62] */ }
        /* Footer Polish */
        footer {
            background-color: #0cc0df; /* [63] */
            padding: 15px; /* [63] */ /* More padding */
            text-align: center; /* [64] */
            border-radius: 5px 5px 0 0; /* [64] */ /* Rounded top corners */
            font-size: 0.9em; /* [64] */
            margin-top: 40px; /* [64] */
            color: white;
        }
        /* Pin Animations */
        .guess-pin, .real-location-pin {
            position: absolute; /* [66] */
            width: 24px; /* [66] */
            height: 36px; /* [66] */
            background-size: contain; /* [67] */
            background-repeat: no-repeat; /* [67] */
            /* Base transform for centering pin point at LngLat */
            transform: translate3d(-50%, -100%, 0); /* [67] */
            pointer-events: none; /* [67] */

            /* Animation properties */
            opacity: 0;
            transform: translate3d(-50%, -100%, 0) scale(0.3) translateY(-40px); /* Start smaller, higher, and invisible */
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s ease-out;
        }
        .guess-pin.visible, .real-location-pin.visible {
            opacity: 1;
            transform: translate3d(-50%, -100%, 0) scale(1) translateY(0); /* End at normal size and position */
        }
        .guess-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%23e53e3e" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>'); /* [68] */
            z-index: 101; /* [68] */
        }
        .real-location-pin {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36"><path fill="%2328a745" d="M12,0C5.373,0,0,5.373,0,12c0,8.75,12,24,12,24s12-15.25,12-24C24,5.373,18.627,0,12,0z M12,17.5 c-3.033,0-5.5-2.467-5.5-5.5s2.467-5.5,5.5-5.5s5.5,2.467,5.5,5.5S15.033,17.5,12,17.5z"/><circle fill="white" cx="12" cy="12" r="4"/></svg>'); /* [69] */
            z-index: 102; /* [69] */
        }
        #next-round-btn {
            position: absolute; /* [70] */
            bottom: 20px; /* [70] */
            left: 50%; /* [70] */
            transform: translateX(-50%); /* [70] */
            padding: 12px 30px; /* [70] */
            font-size: 1.1em; /* [70] */
            background-color: #0cc0df; /* [70] */
            color: white; /* [70] */
            border: none; /* [70] */
            border-radius: 5px; /* [71] */
            cursor: pointer; /* [71] */
            z-index: 110; /* [71] */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* [72] */
            transition: background-color 0.3s; /* [72] */
        }
        #next-round-btn:hover {
            background-color: #0aa8c4; /* [73] */
        }
        /* REMOVE Corner Score Displays */
        #round-score-display, #total-score-display {
            display: none !important; /* [74, 75, 76, 77] */ /* Effectively removes them */
        }
        /* Game Status Bar Polish */
        .game-status-bar {
            background-color: #e8f4f8; /* [78] */
            padding: 15px; /* [78] */
            border-radius: 8px; /* [78] */ /* Slightly larger radius */
            margin: 15px 0; /* [79] */
            display: flex; /* [79] */
            justify-content: space-around; /* [79] */ /* Better spacing */
            align-items: center; /* [79] */
            flex-wrap: wrap; /* [79] */
            gap: 10px; /* [79] */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .status-item {
            display: flex; /* [80] */
            flex-direction: column; /* [80] */
            align-items: center; /* [80] */
            font-size: 14px; /* [80] */
            color: #555; /* Slightly softer text color */
        }
        .status-value {
            font-weight: bold; /* [81] */
            font-size: 16px; /* [81] */
            color: #007cba; /* [81] */
            margin-bottom: 3px; /* Space between value and label */
        }
        /* Ensure maptiler controls remain hidden */
        .maptiler-ctrl-group,
        .maptiler-ctrl,
        .maplibregl-ctrl-group,
        .maplibregl-ctrl {
            display: none !important; /* [65] */
        }
    </style>
</head>
<body>
    <div id="loading-overlay" class="loading-overlay"><div class="spinner"></div></div>
    <div id="connectionStatus" class="connection-status status-connecting">
        <span class="live-indicator"></span>
        <span id="statusText">Not Connected</span>
    </div>
    
    <div id="notification" class="notification"></div>
    
    <header>
        <h1>Map Guessr - Live Session Game</h1>
        <p>Real-time Connected Multiplayer Experience</p>
    </header>
    <main>
        <div id="session-join" class="session-container view-container visible"> {/* [82] */}
            <h2>Join Live Game Session</h2>
            <p>Enter your session code and player name to join the live game.</p>
            <div class="session-form">
                <input type="text" id="session-code" placeholder="Session Code" maxlength="10">
                <br>
                <input type="text" id="player-name" placeholder="Your Name" maxlength="30"> {/* [83] */}
                <br>
                <button onclick="joinSession()" id="join-button">Join Live Session</button>
            </div>
            <div id="join-message"></div>
        </div>

        <div id="session-waiting" class="session-container view-container" style="display: none;"> {/* [84] */}
            <h2>🔴 Live Session Joined!</h2>
            <div id="session-info" class="session-info"></div>
            
            <div class="live-players">
                <h4>👥 Live Players</h4>
                <div id="players-list"></div> {/* [85] */}
            </div>
            
            <div class="waiting-message">
                <h3>⏳ Waiting for game to start...</h3>
                <p><strong>Live Status:</strong> Connected and waiting for administrator instructions</p>
                <p>You'll be automatically notified when the game becomes available!</p> {/* [86] */}
            </div>
            
            <div class="game-status-bar">
                <div class="status-item">
                    <span class="status-value" id="live-status">waiting</span>
                    <span>Status</span> {/* [87] */}
                </div>
                <div class="status-item">
                    <span class="status-value" id="live-players-count">0</span>
                    <span>Players</span>
                </div>
                <div class="status-item"> {/* [88] */}
                    <span class="status-value" id="live-connections">0</span>
                    <span>Connected</span>
                </div>
            </div>
            
            <button class="start-game-btn" onclick="startGame()" id="start-button" style="display: none;">🎮 Start Playing</button> {/* [89] */}
            <div id="wait-message"></div>
        </div>

        <div id="game-container" class="game-container view-container"> {/* [42] */}
            <section>
                <h2>🎯 Live Game in Progress</h2>
                <div id="game-status" class="game-status-bar"></div> {/* [90] */}
                <div class="maps-container">
                    <div id="maptiler-map"></div>
                    <div id="overlay-map"></div>
                </div>
                <div class="submit-container">
                    <button class="submit-btn" id="submit-guess">Submit Guess</button> {/* [91] */}
                </div>
            </section>
            
            <section>
                <h2>📊 Game Progress</h2>
                <ul> {/* [92] */}
                    <li id="location-text">Waiting for location...</li>
                    <li id="guessed-coords">Make your guess on the overlay map...</li>
                    <li id="submit-status">Place your guess on the overlay map...</li>
                    <li id="points-score">Points: - | Total: 0 points</li> {/* [93] */}
                    <li id="round-count">Round: 1 | Game: 1</li> {/* [94] */}
                </ul>
            </section>

            <div id="leaderboard-container">
                <div class="leaderboard">
                    <h3>🏆 Live Leaderboard</h3>
                    <div id="leaderboard-content"> {/* [95] */}
                        <p>Waiting for scores...</p>
                    </div>
                </div>
            </div>
        </div>
    </main>
    <footer>
        <p>Live WebSocket-Based Map Guessr Game</p> {/* [96] */}
    </footer>

    <div id="round-score-display"></div>
    <div id="total-score-display"></div>

    <script>
        // --- Configuration ---
        const API_BASE_URL = 'https://game-session-worker.games-6cb.workers.dev';
        const INITIAL_ZOOM_LEVEL = 15; /* [97] */
        const OVERLAY_INITIAL_CENTER = [0, 0];
        const OVERLAY_INITIAL_ZOOM = -0.5;
        const MAX_SCORE_PER_ROUND = 5000;
        const PERFECT_SCORE_THRESHOLD_METERS = 100; /* [98] */
        const SCORE_DECAY_FACTOR = 2000000;

        // --- Session State Variables ---
        let sessionCode = null;
        let playerName = null; /* [99] */
        let playerId = null;
        let sessionData = null;
        let currentRound = 1;
        let currentGame = 1;
        let gameWebSocket = null; /* [100] */
        
        // --- Game State Variables ---
        let mainMap = null;
        let overlayMap = null; /* [101] */
        let currentSdkMarker = null;
        let userGuessLngLat = null;
        let guessPinElement = null;
        let realLocationPinElement = null;
        let actualLocationCoords = null; /* [102] */
        let totalScore = 0;
        let lineLayerVisible = false;
        let gameInProgress = false; /* [103] */

        // --- DOM Element Cache ---
        const DOM = {};
        function cacheDOMElements() {
            DOM.sessionJoin = document.getElementById('session-join'); /* [104] */
            DOM.sessionWaiting = document.getElementById('session-waiting'); /* [104] */
            DOM.gameContainer = document.getElementById('game-container'); /* [105] */
            DOM.sessionInfo = document.getElementById('session-info'); /* [105] */
            DOM.waitMessage = document.getElementById('wait-message'); /* [105] */
            DOM.joinMessage = document.getElementById('join-message'); /* [105] */
            DOM.startButton = document.getElementById('start-button'); /* [105] */
            DOM.locationText = document.getElementById('location-text'); /* [105] */
            DOM.guessedCoordsText = document.getElementById('guessed-coords'); /* [106] */
            DOM.submitStatusText = document.getElementById('submit-status'); /* [106] */
            DOM.pointsScoreText = document.getElementById('points-score'); /* [106] */
            DOM.roundCountText = document.getElementById('round-count'); /* [106] */
            DOM.submitGuessBtn = document.getElementById('submit-guess'); /* [106] */
            DOM.overlayMapElement = document.getElementById('overlay-map'); /* [106] */
            // DOM.roundScoreDisplay = document.getElementById('round-score-display'); // REMOVED [107]
            // DOM.totalScoreDisplay = document.getElementById('total-score-display'); // REMOVED [107]
            DOM.mapsContainer = document.querySelector('.maps-container'); /* [107] */
            DOM.leaderboardContainer = document.getElementById('leaderboard-container'); /* [107] */
            DOM.leaderboardContent = document.getElementById('leaderboard-content'); /* [107] */
            DOM.gameStatus = document.getElementById('game-status'); /* [107] */
            DOM.playersListElement = document.getElementById('players-list'); /* [108] */
            DOM.liveStatus = document.getElementById('live-status'); /* [108] */
            DOM.livePlayersCount = document.getElementById('live-players-count'); /* [108] */
            DOM.liveConnections = document.getElementById('live-connections'); /* [108] */
            DOM.joinButton = document.getElementById('join-button'); /* [108] */
            DOM.notificationElement = document.getElementById('notification'); // Cache notification element
            DOM.loadingOverlay = document.getElementById('loading-overlay'); // ADDED
        } /* [109] */

        // --- UI Utility Functions ---
        function showLoading() {
            if (DOM.loadingOverlay) {
                DOM.loadingOverlay.classList.add('visible');
            }
        }
        function hideLoading() {
            if (DOM.loadingOverlay) {
                DOM.loadingOverlay.classList.remove('visible');
            }
        }

        // --- WebSocket Management ---
        class GameWebSocket {
            constructor(sessionCode) {
                this.sessionCode = sessionCode;
                this.ws = null; /* [110] */
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectAttempts = 0;
                this.connect(); /* [111] */
            }

            connect() {
                try {
                    updateConnectionStatus('connecting'); /* [112] */
                    const WS_BASE_URL = 'wss://game-session-worker.games-6cb.workers.dev';
                    const wsUrl = `${WS_BASE_URL}/ws?session=${this.sessionCode}`;

                    
                    this.ws = new WebSocket(wsUrl);
                    this.ws.onopen = () => { /* [113] */
                        console.log('WebSocket connected');
                        updateConnectionStatus('connected'); /* [114] */
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 1000;
                        
                        // Request initial session update
                        this.send({ type: 'request_update' }); /* [115] */
                        // Send ping every 30 seconds
                        this.pingInterval = setInterval(() => {
                            if (this.ws?.readyState === WebSocket.OPEN) {
                                this.send({ type: 'ping' }); /* [116] */
                            }
                        }, 30000); /* [117] */
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message); /* [118] */
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error); /* [119] */
                        }
                    };
                    this.ws.onclose = () => { /* [120] */
                        console.log('WebSocket disconnected');
                        updateConnectionStatus('disconnected'); /* [121] */
                        if (this.pingInterval) {
                            clearInterval(this.pingInterval); /* [122] */
                        }
                        this.scheduleReconnect(); /* [123] */
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        updateConnectionStatus('disconnected'); /* [124] */
                    };
                    
                } catch (error) {
                    console.error('Error creating WebSocket:', error);
                    updateConnectionStatus('disconnected'); /* [125] */
                    this.scheduleReconnect();
                }
            }

            send(message) {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message)); /* [126] */
                } else {
                    console.warn('WebSocket not connected, message not sent:', message); /* [127] */
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'session_update':
                        handleSessionUpdate(message.data); /* [128] */
                        if (message.event) {
                            handleSessionEvent(message.event); /* [129] */
                        }
                        break;
                    case 'join_success': /* [130] */
                        showNotification('Successfully joined the game!', 'success'); /* [131] */
                        // showSessionWaiting(); // Moved to handleSessionUpdate
                        // hideLoading(); // Moved to handleSessionUpdate
                        break;
                        
                    case 'score_success':
                        showNotification(`Score posted! Total: ${message.totalScore}`, 'success'); /* [132] */
                        break;
                        
                    case 'session_deleted':
                        showNotification('Session was deleted by admin', 'error');
                        resetToJoinScreen(); /* [133] */
                        break;
                        
                    case 'error':
                        showNotification(`Error: ${message.message}`, 'error'); /* [134] */
                        break;
                        
                    case 'pong':
                        // Server responded to ping
                        break;
                    case 'connected': /* [135] */
                        console.log('WebSocket:', message.message); /* [136] */
                        break;
                        
                    default:
                        console.log('Unknown message type:', message.type, message); /* [137] */
                }
            }
            
            scheduleReconnect() {
                if (!sessionCode) return; /* [138] */
                // Don't reconnect if we've left the session
                
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts), this.maxReconnectDelay); /* [139] */
                
                console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
                setTimeout(() => { /* [140] */
                    if (sessionCode) {
                        this.connect();
                    }
                }, delay); /* [141] */
            }

            close() {
                if (this.pingInterval) {
                    clearInterval(this.pingInterval); /* [142] */
                }
                if (this.ws) {
                    this.ws.close(); /* [143] */
                }
            }
        }

        // --- WebSocket Event Handlers ---
        function handleSessionUpdate(data) {
            const isFirstUpdate = !sessionData; // Check if this is the first data received
            sessionData = data; /* [144] */
            updateLiveSessionInfo(); /* [144] */
            updateLivePlayersList(); /* [144] */
            updateLiveLeaderboard(); /* [144] */
            
            // Check if game state changed
            checkGameAvailability(); /* [145] */

            if (isFirstUpdate && DOM.sessionJoin && DOM.sessionJoin.classList.contains('visible')) { // If we were on join screen
                 showSessionWaiting();
                 hideLoading();
            }
        }

        function handleSessionEvent(event) {
            let message = null;
            switch (event.type) { /* [146] */
                case 'player_joined':
                    message = `${event.playerName} joined the game`; /* [147] */
                    break;
                case 'player_left':
                    message = 'A player left the game'; /* [148] */
                    break;
                case 'player_kicked':
                    message = `A player was kicked: ${event.reason || 'No reason given'}`; /* [149] */
                    break;
                case 'score_updated':
                    message = `Score update: ${event.score} points`; /* [150] */
                    break;
                case 'round_toggled':
                    message = `Round ${event.roundId} ${event.open ? 'opened' : 'closed'}`; /* [151] */
                    checkGameAvailability(); // Re-check availability
                    break;
                case 'game_toggled': /* [152] */
                    message = `Game ${event.gameId} ${event.open ? 'opened' : 'closed'}`; /* [153] */
                    checkGameAvailability(); // Re-check availability
                    break;
                case 'session_started': /* [154] */
                    message = 'Session started - cities generated'; /* [155] */
                    break;
                case 'cities_approved':
                    message = 'Cities approved - game is now active';
                    checkGameAvailability(); /* [156] */
                    break;
                case 'session_ended':
                    message = `Session ended: ${event.reason || 'No reason given'}`; /* [157] */
                    break;
            }
            
            if (message) {
                showNotification(message); /* [158] */
            }
        }

        function updateLiveSessionInfo() {
            if (!sessionData) return; /* [159] */
            DOM.sessionInfo.innerHTML = `
                <h3>Session: ${sessionData.joinCode}</h3>
                <p><strong>Player:</strong> ${playerName}</p>
                <p><strong>Game Type:</strong> ${sessionData.gameType}</p>
                <p><strong>Status:</strong> ${sessionData.status}</p>
            `;
            DOM.liveStatus.textContent = sessionData.status; /* [160] */
            DOM.livePlayersCount.textContent = sessionData.players ? sessionData.players.length : 0; /* [160] */
            DOM.liveConnections.textContent = sessionData.connectionCount || 0; /* [161] */
        }

        function updateLivePlayersList() {
            if (!sessionData || !sessionData.players) return; /* [162] */
            let html = '';
            sessionData.players.forEach(player => {
                const isCurrentPlayer = player.id === playerId;
                let statusClass = player.status === 'active' ? '' : player.status;
                if (isCurrentPlayer) statusClass += ' you';
                
                html += `<div class="player-item ${statusClass}"> {/* [163] */}
                    <div>
                        <strong>${player.name}</strong>${isCurrentPlayer ? ' (You)' : ''} - ${player.status}
                        ${player.note ? ` - <em>${player.note}</em>` : ''}
                    </div> {/* [164] */}
                    <div>${player.score || 0} pts</div>
                </div>`;
            });
            DOM.playersListElement.innerHTML = html || '<p>No players yet</p>'; /* [165] */
        }

        function updateLiveLeaderboard() {
            if (!sessionData || !sessionData.scores) {
                DOM.leaderboardContent.innerHTML = '<p>Waiting for scores...</p>';
                return; /* [166] */
            }
            
            let html = '<table><tr><th>Rank</th><th>Player</th><th>Score</th><th>Status</th></tr>';
            sessionData.scores.forEach((score, index) => { /* [167] */
                const isCurrentPlayer = score.playerId === playerId;
                const rowClass = isCurrentPlayer ? 'current-player' : '';
                html += `<tr class="${rowClass}">
                    <td>${index + 1}</td>
                    <td>${score.playerName}${isCurrentPlayer ? ' (You)' : ''}</td> {/* [168] */}
                    <td>${score.score}</td>
                    <td>${score.status}</td>
                </tr>`;
            });
            html += '</table>'; /* [169] */
            
            DOM.leaderboardContent.innerHTML = html;
        }

        function checkGameAvailability() {
            if (!sessionData) return;
            if (sessionData.status === 'active') { /* [170] */
                // Check if any round is open
                const hasOpenRound = sessionData.rounds && sessionData.rounds.some(round => round.open);
                if (hasOpenRound) { /* [171] */
                    DOM.startButton.style.display = 'block'; /* [172] */
                    showMessage('wait-message', 'Game is active! You can start playing.', 'success'); /* [172] */
                } else {
                    DOM.startButton.style.display = 'none'; /* [173] */
                    showMessage('wait-message', 'Game is active but no rounds are currently open. Waiting for administrator...', 'waiting'); /* [174] */
                }
            } else if (sessionData.status === 'ended') {
                showMessage('wait-message', 'Game has ended. Thank you for playing!', 'info');
                DOM.startButton.style.display = 'none'; /* [175] */
            } else {
                DOM.startButton.style.display = 'none'; /* [176] */
                showMessage('wait-message', `Game status: ${sessionData.status}. Waiting for game to start...`, 'waiting'); /* [177] */
            }
        }

        // --- Connection Status Management ---
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            const textElement = document.getElementById('statusText'); /* [178] */
            
            statusElement.className = 'connection-status';
            
            switch (status) {
                case 'connected':
                    statusElement.classList.add('status-connected');
                    textElement.innerHTML = '<span class="live-indicator" style="background: #28a745;"></span>Live'; /* [179] */
                    break;
                case 'connecting':
                    statusElement.classList.add('status-connecting');
                    textElement.innerHTML = '<span class="live-indicator" style="background: #ffc107;"></span>Connecting...'; /* [180] */
                    break;
                case 'disconnected':
                    statusElement.classList.add('status-disconnected');
                    textElement.innerHTML = '🔴 Disconnected'; /* [181] */
                    break;
            }
        }
        
        function showNotification(message, type = 'info') {
            if (!message || !DOM.notificationElement) return; /* [182] */ // Use cached DOM.notificationElement
            DOM.notificationElement.textContent = message;

            // Reset classes
            DOM.notificationElement.className = 'notification'; // Base class [183]

            // Add type-specific class for styling from CSS
            if (type === 'error') {
                DOM.notificationElement.classList.add('error'); /* [184] */
            } else if (type === 'success') {
                DOM.notificationElement.classList.add('success'); /* [185] */
            } else {
                DOM.notificationElement.classList.add('info'); /* [186] */ // for default or other types
            }

            DOM.notificationElement.classList.add('show'); // Trigger show animation [187]

            setTimeout(() => {
                DOM.notificationElement.classList.remove('show'); // Trigger hide animation [188]
            }, 4000);
        }

        // --- Session Management ---
        function joinSession() {
            const code = document.getElementById('session-code').value.trim().toUpperCase(); /* [189] */
            const name = document.getElementById('player-name').value.trim(); /* [189] */
            
            if (!code || !name) {
                showMessage('join-message', 'Please enter both session code and your name.', 'error'); /* [190] */
                return; /* [190] */
            }
            
            sessionCode = code; /* [191] */
            playerName = name; /* [191] */
            playerId = generatePlayerId(); /* [191] */
            
            DOM.joinButton.disabled = true; /* [192] */
            DOM.joinButton.textContent = 'Connecting...'; /* [192] */
            showLoading(); // ADDED

            try {
                // Connect to WebSocket
                gameWebSocket = new GameWebSocket(sessionCode); /* [193] */
                // Send join player message after connection
                setTimeout(() => {
                    if (gameWebSocket?.ws?.readyState === WebSocket.OPEN) {
                        gameWebSocket.send({
                            type: 'join_player', /* [194] */
                            playerId: playerId,
                            playerName: playerName
                        });
                        // showSessionWaiting(); // This will be called after successful join or update
                        // hideLoading will be called after session update or if join fails
                    } else {
                        showMessage('join-message', 'Failed to connect to session. Please try again.', 'error'); /* [196] */
                        DOM.joinButton.disabled = false; /* [196] */
                        DOM.joinButton.textContent = 'Join Live Session'; /* [196] */
                        hideLoading(); // ADDED
                        resetToJoinScreen(); // Go back if connection fails
                    }
                }, 1500); // Increased delay slightly for WS to open /* [197] */
            } catch (error) {
                showMessage('join-message', `Failed to join session: ${error.message}`, 'error'); /* [198] */
                DOM.joinButton.disabled = false; /* [198] */
                DOM.joinButton.textContent = 'Join Live Session'; /* [198] */
                hideLoading(); // ADDED
            }
        }

        function showSessionWaiting() {
            // DOM.sessionJoin.style.display = 'none'; // [199]
            // DOM.sessionWaiting.style.display = 'block'; // [199]
            if (DOM.sessionJoin) DOM.sessionJoin.classList.remove('visible');
            setTimeout(() => {
                if (DOM.sessionJoin) DOM.sessionJoin.style.display = 'none';
                if (DOM.sessionWaiting) {
                    DOM.sessionWaiting.style.display = 'block';
                    // Ensure the new view is ready for transition
                    requestAnimationFrame(() => {
                         DOM.sessionWaiting.classList.add('visible');
                    });
                }
            }, 400); // Match CSS transition duration
        }

        function resetToJoinScreen() {
            if (gameWebSocket) {
                gameWebSocket.close(); /* [200] */
                gameWebSocket = null; /* [200] */
            }
            
            sessionCode = null; /* [201] */
            playerName = null; /* [201] */
            playerId = null; /* [201] */
            sessionData = null; /* [201] */
            gameInProgress = false; /* [201] */
            
            if (DOM.gameContainer) DOM.gameContainer.classList.remove('visible');
            if (DOM.sessionWaiting) DOM.sessionWaiting.classList.remove('visible');

            setTimeout(() => {
                if (DOM.gameContainer) DOM.gameContainer.style.display = 'none';
                if (DOM.sessionWaiting) DOM.sessionWaiting.style.display = 'none';
                if (DOM.sessionJoin) {
                    DOM.sessionJoin.style.display = 'block';
                     requestAnimationFrame(() => {
                        DOM.sessionJoin.classList.add('visible');
                    });
                }
            }, 400);

            DOM.joinButton.disabled = false; /* [202] */
            DOM.joinButton.textContent = 'Join Live Session'; /* [202] */
            
            updateConnectionStatus('disconnected'); /* [203] */
            hideLoading(); // Ensure loading is hidden
        }

        // --- Game Functions ---
        function startGame() {
            if (!sessionData || sessionData.status !== 'active') {
                showNotification('Game is not active yet. Please wait.', 'error'); /* [204] */
                return; /* [204] */
            }
            
            // Find the first open round and game
            const openRound = sessionData.rounds.find(round => round.open); /* [205] */
            if (!openRound) {
                showNotification('No rounds are currently open. Please wait for administrator.', 'error'); /* [206] */
                return; /* [206] */
            }
            
            const openGame = openRound.games.find(game => game.open); /* [207] */
            if (!openGame) {
                showNotification('No games are currently open in this round. Please wait for administrator.', 'error'); /* [208] */
                return; /* [208] */
            }
            
            currentRound = openRound.id; /* [209] */
            currentGame = openGame.id; /* [209] */
            gameInProgress = true; /* [209] */
            
            if(DOM.sessionWaiting) DOM.sessionWaiting.classList.remove('visible');
            showLoading(); // Show loader while maps initialize

            setTimeout(() => {
                if(DOM.sessionWaiting) DOM.sessionWaiting.style.display = 'none';
                if(DOM.gameContainer) {
                    DOM.gameContainer.style.display = 'block';
                    requestAnimationFrame(() => {
                        DOM.gameContainer.classList.add('visible');
                    });
                }

                initializeMaps().then(() => {
                    loadGameLocation(); // This will hideLoading after location is set
                }).catch(() => {
                    hideLoading(); // Hide loading on map init error
                });
            }, 400); /* [211] */
        }

        async function loadGameLocation() {
            try {
                DOM.locationText.textContent = 'Loading location...'; /* [212] */
                showLoading(); // ADDED - show general loader
                // Get city for current round/game using REST API
                const response = await fetch(`${API_BASE_URL}/api/cities?round=${currentRound}&game=${currentGame}`, {
                    headers: { 'X-Session-Code': sessionCode } /* [213] */
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`); /* [214] */
                }
                
                const cityData = await response.json(); /* [215] */
                const cityName = cityData.city;
                
                DOM.locationText.textContent = `Finding a spot in ${cityName}...`; /* [216] */
                // Geocode the city using our proxy
                const geocodingResponse = await fetch(`${API_BASE_URL}/api/geocode?city=${encodeURIComponent(cityName)}`, {
                    headers: { 'X-Session-Code': sessionCode }
                });
                const geocodingData = await geocodingResponse.json(); /* [217] */
                
                if (!geocodingData.features || geocodingData.features.length === 0) {
                    throw new Error(`Could not find location for ${cityName}`); /* [218] */
                }
                
                const feature = geocodingData.features[0]; /* [219] */
                const bounds = feature.bbox;
                const center = feature.center;
                
                let randomLngLatArray;
                if (bounds) { /* [220] */
                    randomLngLatArray = getRandomCoordinateInBounds(bounds); /* [221] */
                } else if (center) {
                    randomLngLatArray = [center[0] + (Math.random() - 0.5) * 0.02, center[1] + (Math.random() - 0.5) * 0.02]; /* [222] */
                } else {
                    throw new Error(`No location data for ${cityName}`); /* [223] */
                }
                
                if (mainMap) {
                    mainMap.jumpTo({ center: randomLngLatArray, zoom: INITIAL_ZOOM_LEVEL, essential: true }); /* [224] */
                }
                
                DOM.locationText.textContent = `Location: ${feature.place_name || cityName}`; /* [225] */
                addOrUpdateSdkMarker(randomLngLatArray); /* [225] */
                updateGameStatus(); /* [225] */
                
            } catch (error) {
                DOM.locationText.textContent = `Error loading location: ${error.message}`; /* [226] */
                console.error('Location loading error:', error); /* [226] */
            } finally {
                hideLoading(); // ADDED - hide loader regardless of outcome
            }
        }

        function updateGameStatus() {
            DOM.roundCountText.textContent = `Round: ${currentRound} | Game: ${currentGame}`; /* [227] */
            DOM.gameStatus.innerHTML = `
                <div class="status-item">
                    <span class="status-value">Round ${currentRound}</span>
                    <span>Current Round</span>
                </div>
                <div class="status-item">
                    <span class="status-value">Game ${currentGame}</span> {/* [228] */}
                    <span>Current Game</span>
                </div>
                <div class="status-item">
                    <span class="status-value">${totalScore}</span>
                    <span>Your Score</span> {/* [229] */}
                </div>
                <div class="status-item">
                    <span class="status-value">${sessionCode}</span>
                    <span>Session</span>
                </div> {/* [230] */}
            `; /* [231] */
        }

        async function submitGuess() {
            console.log("Submit button clicked."); /* [232] */
            const guess = convertToLngLat(userGuessLngLat); /* [232] */
            const actual = convertToLngLat(actualLocationCoords); /* [232] */

            if (!guess) {
                DOM.submitStatusText.textContent = 'Please make a guess by clicking on the overlay map.'; /* [233] */
                return; /* [233] */
            }
            if (!actual) {
                DOM.submitStatusText.textContent = 'Error: No actual location set for scoring.'; /* [234] */
                return; /* [234] */
            }
            showLoading(); // Show loading while processing

            const scoreResult = calculateGeoGuessrScore(actual.lat, actual.lng, guess.lat, guess.lng); /* [235] */
            if (isNaN(scoreResult.score) || isNaN(scoreResult.distance)) {
                DOM.submitStatusText.textContent = 'Error: Score calculation failed.'; /* [236] */
                hideLoading();
                return; /* [236] */
            }

            totalScore += scoreResult.score; /* [237] */
            DOM.pointsScoreText.innerHTML = `<strong>Round Score:</strong> ${scoreResult.score} points <em>(${(scoreResult.distance / 1000).toFixed(2)} km)</em> <br> <strong>Total Score:</strong> ${totalScore} points`; /* [237] */ // Modified for clarity
            DOM.submitStatusText.textContent = `Guess submitted! You were ${(scoreResult.distance / 1000).toFixed(2)} km away.`; /* [238] */
            
            updateGameStatus(); // To update total score in the status bar

            if (currentSdkMarker && currentSdkMarker.getElement()) {
                currentSdkMarker.getElement().style.display = 'block'; /* [239] */
            }
            
            setOverlayMapFullscreen(true, { guess: guess, actual: actual }); /* [240] */
            placeRealLocationPin(actual); /* [240] */

            if (overlayMap.getLayer('line-layer')) {
                overlayMap.setLayoutProperty('line-layer', 'visibility', 'visible'); /* [241] */
            }
            lineLayerVisible = true; /* [241] */
            updateLineBetweenPins(); /* [241] */

            // displayScoresPopup(scoreResult.score, totalScore); // REMOVED [242]
            DOM.submitGuessBtn.disabled = true; /* [242] */

            // Post score via WebSocket
            if (gameWebSocket?.ws?.readyState === WebSocket.OPEN) {
                gameWebSocket.send({
                    type: 'post_score',
                    playerId: playerId,
                    score: scoreResult.score, /* [243] */
                    roundId: currentRound,
                    gameId: currentGame
                }); /* [244] */
            } else {
                showNotification('Warning: Could not save score - connection lost', 'error'); /* [245] */
            }
            hideLoading(); // Hide loading after processing

            // Show continue button or auto-continue based on game state
            setTimeout(() => {
                checkForNextGame(); /* [246] */
            }, 3000); /* [246] */
        }

        function checkForNextGame() {
            if (!sessionData) return; /* [247] */
            const currentRoundData = sessionData.rounds.find(r => r.id === currentRound);
            if (!currentRoundData) {
                showWaitingForNextGame('Current round not found. Please wait for administrator instructions.'); /* [248] */
                return; /* [248] */
            }
            
            // Look for next game in current round
            const nextGameInRound = currentRoundData.games.find(g => g.id > currentGame && g.open); /* [249] */
            if (nextGameInRound) {
                showContinueButton(() => proceedToNextGame(nextGameInRound.id, currentRound)); /* [250] */
            } else {
                // Look for next round
                const nextRound = sessionData.rounds.find(r => r.id > currentRound && r.open); /* [251] */
                if (nextRound && nextRound.games.some(g => g.open)) {
                    const firstGameInRound = nextRound.games.find(g => g.open);
                    showContinueButton(() => proceedToNextGame(firstGameInRound.id, nextRound.id)); /* [252] */
                } else {
                    showWaitingForNextGame('No more games are currently available. Waiting for administrator...'); /* [253] */
                }
            }
        }

        function showContinueButton(callback) {
            DOM.submitStatusText.innerHTML = `
                Guess submitted!
                <button onclick="continueToNext()" style="margin-left: 10px; padding: 8px 16px; background: #0cc0df; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Continue to Next Game
                </button>
            `; /* [254] */
            window.continueToNext = callback; /* [255] */
        }

        function showWaitingForNextGame(message) {
            DOM.submitStatusText.textContent = message; /* [256] */
        }

        function proceedToNextGame(gameId, roundId) {
            currentGame = gameId; /* [257] */
            currentRound = roundId; /* [257] */
            resetGameUI();
            loadGameLocation();
        }

        function resetGameUI() {
            DOM.locationText.textContent = 'Loading new location...'; /* [258] */
            DOM.guessedCoordsText.textContent = 'Make your guess on the overlay map...'; /* [258] */
            DOM.submitStatusText.textContent = 'Place your guess on the overlay map...'; /* [258] */
            // hideScoresPopup(); // REMOVED [259]

            if (currentSdkMarker) {
                currentSdkMarker.remove(); /* [260] */
                currentSdkMarker = null; /* [260] */
            }
            if (guessPinElement) {
                guessPinElement.remove(); /* [261] */
                guessPinElement = null; /* [261] */
            }
            userGuessLngLat = null; /* [261] */
            if (overlayMap) overlayMap.off('move', updateGuessPinPositionHandler); /* [261] */ // Add check for overlayMap

            if (realLocationPinElement) {
                realLocationPinElement.remove(); /* [263] */
                realLocationPinElement = null; /* [263] */
            }
           if (overlayMap) overlayMap.off('move', updateRealLocationPinPositionHandler); /* [263] */ // Add check for overlayMap
            
            actualLocationCoords = null; /* [264] */
            if (overlayMap && overlayMap.getLayer('line-layer')) { /* [264] */
                overlayMap.setLayoutProperty('line-layer', 'visibility', 'none'); /* [265] */
            }
            lineLayerVisible = false; /* [265] */

            setOverlayMapFullscreen(false); /* [266] */
            DOM.submitGuessBtn.disabled = false; /* [266] */
            updateGameStatus(); // Ensure score display in status bar is up-to-date (e.g. total score)
        }

        // --- Utility Functions ---
        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); /* [267] */
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId); /* [268] */
            const className = type === 'error' ? 'error-message' : 
                             type === 'success' ? 'success-message' :  /* [269] */
                             type === 'waiting' ? 'waiting-message' :  /* [270] */
                             'session-info'; /* [271] */
            element.innerHTML = `<div class="${className}">${message}</div>`;
        }

        function getRandomCoordinateInBounds(bounds) {
            const [minLng, minLat, maxLng, maxLat] = bounds;
            const buffer = 0.001; /* [272] */
            const bufferedMinLng = minLng + (maxLng - minLng) * buffer; /* [273] */
            const bufferedMinLat = minLat + (maxLat - minLat) * buffer; /* [273] */
            const bufferedMaxLng = maxLng - (maxLng - minLng) * buffer; /* [274] */
            const bufferedMaxLat = maxLat - (maxLat - minLat) * buffer; /* [274] */
            const randomLng = bufferedMinLng + (bufferedMaxLng - bufferedMinLng) * Math.random(); /* [275] */
            const randomLat = bufferedMinLat + (bufferedMaxLat - bufferedMinLat) * Math.random(); // Typo fix: buffer -> Math.random()
            return [randomLng, randomLat]; /* [276] */
        }

        function calculateDistanceInMeters(lat1, lon1, lat2, lon2) {
            if ([lat1, lon1, lat2, lon2].some(coord => typeof coord !== 'number')) {
                console.error("Invalid input types for calculateDistanceInMeters:", lat1, lon1, lat2, lon2);
                return NaN; /* [277] */
            }
            const R = 6371e3; /* [278] */
            const φ1 = lat1 * Math.PI / 180; /* [278] */
            const φ2 = lat2 * Math.PI / 180; /* [279] */
            const Δφ = (lat2 - lat1) * Math.PI / 180; /* [279] */
            const Δλ = (lon2 - lon1) * Math.PI / 180; /* [280] */
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2); /* [280] */
            const c = 2 * Math.atan2(Math.sqrt(Math.max(0, a)), Math.sqrt(Math.max(0, 1 - a))); /* [281] */
            return R * c; /* [282] */
        }

        function calculateGeoGuessrScore(lat1, lon1, lat2, lon2) {
            const distance = calculateDistanceInMeters(lat1, lon1, lat2, lon2);
            if (isNaN(distance)) { /* [283] */
                console.error("Distance calculation returned NaN.");
                return { distance: NaN, score: NaN }; /* [284] */
            }
            let score;
            if (distance <= PERFECT_SCORE_THRESHOLD_METERS) { /* [285] */
                score = MAX_SCORE_PER_ROUND; /* [286] */
            } else {
                score = MAX_SCORE_PER_ROUND * Math.exp(-distance / SCORE_DECAY_FACTOR); /* [287] */
                score = Math.max(0, Math.round(score)); /* [287] */
            }
            return { distance, score }; /* [288] */
        }

        function convertToLngLat(lngLatInput) {
            if (lngLatInput instanceof maptilersdk.LngLat) {
                return lngLatInput; /* [289] */
            }
            if (Array.isArray(lngLatInput) && lngLatInput.length === 2 &&
                typeof lngLatInput[0] === 'number' && typeof lngLatInput[1] === 'number') {
                return new maptilersdk.LngLat(lngLatInput[0], lngLatInput[1]); /* [290] */
            }
            console.error("convertToLngLat received invalid LngLat data:", lngLatInput); /* [291] */
            return null;
        }

        // --- Pin Management ---
        function createPinElement(className) {
            const element = document.createElement('div');
            element.className = className; /* [292] */
            return element;
        }

        function updatePinPosition(mapInstance, pinEl, lngLat) {
            if (!mapInstance || !pinEl || !lngLat) return;
            const validLngLat = convertToLngLat(lngLat); /* [293] */
            if (!validLngLat) {
                 console.error("Invalid LngLat object for pin positioning:", lngLat); /* [294] */
                 return; /* [294] */
            }
            const pixelCoords = mapInstance.project(validLngLat);
            pinEl.style.left = `${pixelCoords.x}px`; /* [295] */
            pinEl.style.top = `${pixelCoords.y}px`; /* [295] */
            pinEl.style.display = 'block';
        }

        function placeGuessPin(lngLat) {
            console.log('Attempting to place custom guess pin at LngLat:', lngLat); /* [296] */
            userGuessLngLat = convertToLngLat(lngLat); /* [296] */
            if (!userGuessLngLat) return;

            if (guessPinElement) guessPinElement.remove();
            guessPinElement = createPinElement('guess-pin'); /* [292] */
            overlayMap.getCanvasContainer().appendChild(guessPinElement);
            updatePinPosition(overlayMap, guessPinElement, userGuessLngLat); /* [297] */

            // Trigger animation
            requestAnimationFrame(() => { // Use rAF for smoother start
                if (guessPinElement) guessPinElement.classList.add('visible');
            });

            DOM.guessedCoordsText.textContent = `Guessed Location: Lng: ${userGuessLngLat.lng.toFixed(6)}, Lat: ${userGuessLngLat.lat.toFixed(6)}`; /* [297] */
            DOM.submitStatusText.textContent = 'Guess placed. Click Submit!'; /* [297] */

            overlayMap.off('move', updateGuessPinPositionHandler); /* [298] */
            overlayMap.on('move', updateGuessPinPositionHandler); /* [298] */
            console.log("Guess pin placed. userGuessLngLat:", userGuessLngLat); /* [298] */
        }
        
        const updateGuessPinPositionHandler = () => updatePinPosition(overlayMap, guessPinElement, userGuessLngLat); /* [299] */
        
        function placeRealLocationPin(lngLat) {
            console.log('Attempting to place custom real location pin at LngLat:', lngLat); /* [300] */
            const validLngLat = convertToLngLat(lngLat); /* [300] */
            if(!validLngLat) return;
            if (realLocationPinElement) realLocationPinElement.remove();
            realLocationPinElement = createPinElement('real-location-pin'); /* [292] */
            overlayMap.getCanvasContainer().appendChild(realLocationPinElement);
            updatePinPosition(overlayMap, realLocationPinElement, validLngLat); /* [301] */

            // Trigger animation
            requestAnimationFrame(() => { // Use rAF for smoother start
               if (realLocationPinElement) realLocationPinElement.classList.add('visible');
            });

            overlayMap.off('move', updateRealLocationPinPositionHandler); /* [301] */
            overlayMap.on('move', updateRealLocationPinPositionHandler); /* [301] */
            console.log("Real location pin placed. actualLocationCoords:", actualLocationCoords); /* [301] */
        }
        
        const updateRealLocationPinPositionHandler = () => updatePinPosition(overlayMap, realLocationPinElement, actualLocationCoords); /* [302] */
        
        // --- Map Interaction & UI Updates ---
        function updateLineBetweenPins() {
            if (!lineLayerVisible || !overlayMap || !userGuessLngLat || !actualLocationCoords) return;
            const validUserGuess = convertToLngLat(userGuessLngLat); /* [303] */
            const validActualLocation = convertToLngLat(actualLocationCoords); /* [303] */

            if (!validUserGuess || !validActualLocation) {
                console.error("Invalid LngLat objects for drawing line:", userGuessLngLat, actualLocationCoords); /* [304] */
                return; /* [304] */
            }

            const lineGeoJSON = {
                'type': 'Feature',
                'geometry': {
                    'type': 'LineString',
                    'coordinates': [
                        [validUserGuess.lng, validUserGuess.lat], /* [305] */
                        [validActualLocation.lng, validActualLocation.lat]
                    ]
                }
            };
            const source = overlayMap.getSource('line-source'); /* [306] */
            if (source) {
                source.setData(lineGeoJSON); /* [307] */
            }
        }

        function displayScoresPopup(roundScore, currentTotalScore) {
            DOM.roundScoreDisplay.textContent = `Round Score: ${roundScore} points`; /* [308] */
            DOM.totalScoreDisplay.textContent = `Total Score: ${currentTotalScore} points`; /* [308] */
            DOM.roundScoreDisplay.style.display = 'block'; /* [309] */
            DOM.totalScoreDisplay.style.display = 'block'; /* [309] */
        }

        function hideScoresPopup() {
            DOM.roundScoreDisplay.style.display = 'none'; /* [310] */
            DOM.totalScoreDisplay.style.display = 'none'; /* [310] */
        }

        function setOverlayMapFullscreen(isFullscreen, fitBoundsLocations = null) {
            if (isFullscreen) {
                DOM.overlayMapElement.classList.add('overlay-map-fullscreen'); /* [311] */
                overlayMap.resize(); /* [311] */
                if (fitBoundsLocations && fitBoundsLocations.guess && fitBoundsLocations.actual) {
                    const bounds = new maptilersdk.LngLatBounds();
                    bounds.extend(fitBoundsLocations.guess); /* [312] */
                    bounds.extend(fitBoundsLocations.actual); /* [312] */
                    setTimeout(() => {
                        overlayMap.fitBounds(bounds, { padding: 50, duration: 1000, essential: true }); /* [313] */
                    }, 300); /* [313] */
                }
            } else {
                DOM.overlayMapElement.classList.remove('overlay-map-fullscreen'); /* [314] */
                overlayMap.flyTo({ center: OVERLAY_INITIAL_CENTER, zoom: OVERLAY_INITIAL_ZOOM, essential: true, duration: 0 }); /* [314] */
                setTimeout(() => overlayMap.resize(), 450); /* [315] */
            }
        }

        function addOrUpdateSdkMarker(lngLatArray) {
            const lngLatObject = convertToLngLat(lngLatArray); /* [316] */
            if (!lngLatObject) {
                console.error("addOrUpdateSdkMarker received invalid LngLat data:", lngLatArray); /* [317] */
                return; /* [317] */
            }

            if (currentSdkMarker) currentSdkMarker.remove();
            currentSdkMarker = new maptilersdk.Marker().setLngLat(lngLatObject).addTo(mainMap); /* [318] */
            actualLocationCoords = lngLatObject; /* [318] */

            if (currentSdkMarker && currentSdkMarker.getElement()) {
                currentSdkMarker.getElement().style.display = 'none'; /* [319] */
            }
            console.log("actualLocationCoords set to LngLat object:", actualLocationCoords); /* [320] */
        }

        // --- Map Initialization ---
        async function initializeMaps() {
            try {
                // Get map styles using our proxy
                const mainMapStyleResponse = await fetch(`${API_BASE_URL}/api/mapstyle?style=0196cb69-f55f-71f8-9a8f-90fa083f0f67`, {
                    headers: { 'X-Session-Code': sessionCode } /* [321] */
                });
                const overlayMapStyleResponse = await fetch(`${API_BASE_URL}/api/mapstyle?style=0196cb7f-9914-7a9b-aed1-8bfa7b9a0705`, { /* [322] */
                    headers: { 'X-Session-Code': sessionCode }
                });
                const mainMapStyle = await mainMapStyleResponse.json(); /* [323] */
                const overlayMapStyle = await overlayMapStyleResponse.json(); /* [323] */
                // Set up MapTiler SDK with a dummy key (we're using proxied styles)
                maptilersdk.config.apiKey = 'dummy'; /* [324] */
                mainMap = new maptilersdk.Map({
                    container: 'maptiler-map',
                    style: mainMapStyle,
                    center: [0, 0],
                    zoom: 1,
                    interactive: false /* [326] */
                });
                overlayMap = new maptilersdk.Map({ /* [327] */
                    container: 'overlay-map',
                    style: overlayMapStyle,
                    center: OVERLAY_INITIAL_CENTER,
                    zoom: OVERLAY_INITIAL_ZOOM,
                    interactive: true /* [328] */
                });
                overlayMap.on('style.load', () => { /* [329] */
                    // Add line layer for showing distance
                    overlayMap.addSource('line-source', {
                        'type': 'geojson',
                        'data': { 'type': 'Feature', 'geometry': { 'type': 'LineString', 'coordinates': [] } } /* [330] */
                    });
                    overlayMap.addLayer({
                        'id': 'line-layer', 'type': 'line', 'source': 'line-source',
                        'layout': { 'line-join': 'round', 'line-cap': 'round', 'visibility': 'none' }, /* [331] */
                        'paint': { 'line-color': '#000', 'line-width': 2, 'line-dasharray': [0.5, 2] }
                    });
                    overlayMap.on('move', updateLineBetweenPins);

               
                    // Add click handlers for placing guess pins
                    const placeGuessPinHandler = (e) => { /* [332] */
                        if (e.type === 'contextmenu') e.preventDefault();
                        if (!DOM.overlayMapElement.classList.contains('overlay-map-fullscreen')) {
                            placeGuessPin(e.lngLat); /* [333] */
                        } /* [334] */
                    };
                    overlayMap.on('click', placeGuessPinHandler); /* [335] */
                    overlayMap.on('contextmenu', placeGuessPinHandler); /* [335] */
                });

                // Handle overlay map transitions
                DOM.overlayMapElement.addEventListener('transitionend', () => {
                    if (overlayMap) {
                        overlayMap.resize();
                        if (guessPinElement && userGuessLngLat) updateGuessPinPositionHandler(); /* [336] */
                        if (realLocationPinElement && actualLocationCoords) updateRealLocationPinPositionHandler(); /* [336] */
                        updateLineBetweenPins(); /* [336] */
                    }
                });
                // Add submit button handler
                DOM.submitGuessBtn.addEventListener('click', submitGuess); /* [337] */
                console.log('Maps initialized successfully'); /* [338] */
                
            } catch (error) {
                console.error('Failed to initialize maps:', error); /* [339] */
                DOM.locationText.textContent = `Failed to load maps: ${error.message}`; /* [339] */
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements();
            updateConnectionStatus('disconnected'); /* [340] */
            // Set initial view states for opacity transition
            if (DOM.sessionJoin) DOM.sessionJoin.classList.add('visible'); // Already display:block
            if (DOM.sessionWaiting) DOM.sessionWaiting.style.opacity = '0'; // display:none in HTML
            if (DOM.gameContainer) DOM.gameContainer.style.opacity = '0'; // display:none via CSS

            hideLoading(); // Ensure loading is hidden on initial load
        });
        // --- Cleanup on page unload ---
        window.addEventListener('beforeunload', () => {
            if (gameWebSocket) {
                gameWebSocket.close();
            }
        }); /* [341] */
    </script>
</body>
</html>
