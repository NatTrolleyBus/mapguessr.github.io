<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Map Guessr - Live Session Game</title>
    <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptiler-sdk.umd.min.js"></script>
    <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.2.0/maptilersdk.css" rel="stylesheet" />
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
        }
        header {
            background-color: #0cc0df;
            padding: 20px;
            border-radius: 0 0 5px 5px;
        }
        h1 {
            color: #444;
            margin-top: 0;
        }
        main {
            padding: 20px;
            max-width: 1980px;
            margin: 0 auto;
        }
        section {
            margin-bottom: 30px;
        }
        
        /* Connection Status */
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.9em;
            color: white;
            z-index: 1000;
        }
        .connection-status.connected { background-color: #28a745; } /* Green */
        .connection-status.disconnected { background-color: #dc3545; } /* Red */
        .connection-status.connecting { background-color: #ffc107; } /* Yellow */

        /* Notifications */
        .notification-container {
            position: fixed;
            top: 50px;
            right: 10px;
            z-index: 1001;
            width: 300px;
        }
        .notification {
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        .notification.error { border-color: #dc3545; color: #dc3545; }
        .notification.info { border-color: #007bff; color: #007bff; }
        .notification.success { border-color: #28a745; color: #28a745; }

        /* Forms and Buttons */
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="text"],
        input[type="number"],
        button {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            box-sizing: border-box; /* Include padding in width */
            margin-bottom: 10px;
        }
        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Session Display */
        #session-display {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 8px;
            display: none; /* Hidden until a session is active */
        }
        #session-display h2 {
            margin-top: 0;
            color: #007bff;
        }
        #session-id-display {
            font-weight: bold;
            color: #333;
        }

        /* Game Screen */
        #game-screen {
            display: none; /* Hidden until game starts */
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            background-color: #fff;
        }
        #game-screen h2 {
            margin-top: 0;
            color: #007bff;
        }

        /* Map Container */
        .map-container {
            position: relative;
            width: 100%;
            height: 400px; /* Adjust height as needed */
            background-color: #e0e0e0;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
        }
        #map, #overlay-map {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
        #overlay-map {
            z-index: 2; /* Ensure overlay is above base map */
            pointer-events: none; /* Initially allow clicks to pass through */
            opacity: 0; /* Initially hidden */
            transition: opacity 0.5s ease-in-out;
        }
        #overlay-map.active {
            pointer-events: all; /* Enable clicks when active */
            opacity: 1; /* Show when active */
        }

        /* Pin elements */
        .guess-pin, .real-location-pin {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid white;
            background-color: #007bff; /* Blue for guess */
            cursor: grab;
            transform: translate(-50%, -50%); /* Center the pin */
            z-index: 3;
        }
        .real-location-pin {
            background-color: #28a745; /* Green for real location */
        }

        /* Line between pins */
        .line-between-pins {
            position: absolute;
            height: 2px;
            background-color: #000;
            transform-origin: 0% 50%;
            z-index: 2;
        }

        /* Game Status Bar */
        .game-status-bar {
            background-color: #e9f5ff; /* Light blue */
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1em;
            color: #0056b3;
            font-weight: bold;
        }

        /* Battle Royale Status Bar (NEW) */
        .battle-royale-status-bar {
            background-color: #f0f8ff; /* Lighter blue background */
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .battle-royale-status-bar .status-item {
            text-align: center;
        }

        .battle-royale-status-bar .status-value {
            font-size: 2.2em; /* Larger font for key numbers */
            color: #0056b3; /* Darker blue for emphasis */
            font-weight: bold;
            display: block; /* Ensures value is on its own line */
        }

        /* Live Player List */
        #live-player-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 5px;
            background-color: #fff;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 5px;
            background-color: #f0f0f0;
            border-left: 5px solid #007bff;
            border-radius: 5px;
            align-items: center;
        }
        .player-item.you {
            background-color: #e6ffe6;
            border-left-color: #28a745; /* Green for current player */
        }
        .player-item.left {
            border-left-color: #ffc107; /* Orange for left players */
            background-color: #fff5e0;
            opacity: 0.8;
            text-decoration: line-through;
        }
        .player-item.kicked {
            border-left-color: #dc3545; /* Red for kicked players */
            background-color: #ffe6e6;
            opacity: 0.6;
            text-decoration: line-through;
        }
        /* NEW: Eliminated status for Battle Royale */
        .player-item.eliminated {
            border-left-color: #6c757d; /* Grey border */
            background-color: #e9ecef; /* Light grey background */
            opacity: 0.7;
            text-decoration: line-through;
        }


        /* Leaderboard */
        #leaderboard {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 8px;
            display: none; /* Hidden until game ends */
        }
        #leaderboard h2 {
            margin-top: 0;
            color: #007bff;
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 5px;
            background-color: #e6f7ff;
            border-left: 5px solid #007bff;
            border-radius: 5px;
        }
        .leaderboard-item.first {
            background-color: #ffe0b2; /* Gold color */
            border-left-color: #ff9800;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connection-status">Connecting...</div>
    <div class="notification-container" id="notification-container"></div>

    <header>
        <h1>Map Guessr - Live Session Game</h1>
    </header>

    <main>
        <section id="create-join-session">
            <h2>Join or Create Session</h2>
            <div class="form-group">
                <label for="player-name">Your Name:</label>
                <input type="text" id="player-name" placeholder="Enter your name" required />
            </div>
            <div class="form-group">
                <label for="session-id-input">Session ID (optional):</label>
                <input type="text" id="session-id-input" placeholder="Enter existing session ID" />
            </div>
            <button id="create-session-btn">Create New Session</button>
            <button id="join-session-btn">Join Session</button>
        </section>

        <section id="session-display">
            <h2>Session: <span id="session-id-display"></span></h2>
            <div class="waiting-room" id="waiting-room">
                <h3>Waiting for players...</h3>
                <p>Share this Session ID with your friends!</p>
                <button id="copy-session-id-btn">Copy Session ID</button>
                <button id="start-game-btn">Start Game</button>
            </div>

            <div id="game-screen">
                <div class="game-status-bar" id="game-status-bar"></div>

                <div class="battle-royale-status-bar">
                    <div class="status-item">
                        <span class="status-value" id="players-remaining">--</span>
                        <span>Players Remaining</span>
                    </div>
                    <div class="status-item">
                        <span class="status-value" id="time-remaining">--:--</span>
                        <span>Time Left</span>
                    </div>
                </div>

                <div class="map-container">
                    <div id="map"></div>
                    <div id="overlay-map"></div>
                    <div id="guess-pin" class="guess-pin" style="display: none;"></div>
                    <div id="real-location-pin" class="real-location-pin" style="display: none;"></div>
                    <div id="line-between-pins" class="line-between-pins" style="display: none;"></div>
                </div>

                <div class="form-group">
                    <button id="submit-guess-btn" disabled>Submit Guess</button>
                </div>
                <div class="form-group">
                    <p>Current Location: <span id="location-text">Loading map...</span></p>
                </div>
            </div>

            <section id="live-players-section">
                <h3>Live Players:</h3>
                <div id="live-player-list">
                    </div>
            </section>
        </section>

        <section id="leaderboard">
            <h2>Leaderboard</h2>
            <div id="leaderboard-list">
                </div>
            <button id="new-game-btn">Start New Game</button>
        </section>
    </main>

    <script>
        maptilersdk.config.apiKey = 'YOUR_MAPTILER_API_KEY'; // Replace with your MapTiler API Key

        const API_BASE_URL = 'https://game-session-worker.games-6cb.workers.dev/api';
        const WS_BASE_URL = 'wss://game-session-worker.games-6cb.workers.dev/ws';

        let playerName = '';
        let sessionId = '';
        let gameWebSocket;
        let map;
        let overlayMap;
        let userGuessLngLat = null;
        let actualLocationCoords = null;
        let guessPinElement;
        let realLocationPinElement;
        let lineBetweenPinsElement;
        let sessionData = {}; // Cache for current session data

        const DOM = {}; // Object to cache DOM elements

        // Cache DOM elements for efficiency
        function cacheDOMElements() {
            DOM.connectionStatus = document.getElementById('connection-status');
            DOM.notificationContainer = document.getElementById('notification-container');
            DOM.playerNameInput = document.getElementById('player-name');
            DOM.sessionIdInput = document.getElementById('session-id-input');
            DOM.createSessionBtn = document.getElementById('create-session-btn');
            DOM.joinSessionBtn = document.getElementById('join-session-btn');
            DOM.createJoinSessionSection = document.getElementById('create-join-session');
            DOM.sessionDisplay = document.getElementById('session-display');
            DOM.sessionIdDisplay = document.getElementById('session-id-display');
            DOM.waitingRoom = document.getElementById('waiting-room');
            DOM.copySessionIdBtn = document.getElementById('copy-session-id-btn');
            DOM.startGameBtn = document.getElementById('start-game-btn');
            DOM.gameScreen = document.getElementById('game-screen');
            DOM.gameStatusBar = document.getElementById('game-status-bar');
            DOM.mapElement = document.getElementById('map');
            DOM.overlayMapElement = document.getElementById('overlay-map');
            DOM.guessPin = document.getElementById('guess-pin');
            DOM.realLocationPin = document.getElementById('real-location-pin');
            DOM.lineBetweenPins = document.getElementById('line-between-pins');
            DOM.submitGuessBtn = document.getElementById('submit-guess-btn');
            DOM.locationText = document.getElementById('location-text');
            DOM.livePlayerList = document.getElementById('live-player-list');
            DOM.leaderboardSection = document.getElementById('leaderboard');
            DOM.leaderboardList = document.getElementById('leaderboard-list');
            DOM.newGameBtn = document.getElementById('new-game-btn');

            // NEW: Battle Royale UI elements
            DOM.playersRemaining = document.getElementById('players-remaining');
            DOM.timeRemaining = document.getElementById('time-remaining');
        }

        // --- WebSocket Handling ---
        class GameWebSocket {
            constructor(url, onOpen, onMessage, onClose, onError) {
                this.ws = null;
                this.url = url;
                this.onOpen = onOpen;
                this.onMessage = onMessage;
                this.onClose = onClose;
                this.onError = onError;
                this.connect();
            }

            connect() {
                updateConnectionStatus('connecting');
                this.ws = new WebSocket(this.url);
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    updateConnectionStatus('connected');
                    if (this.onOpen) this.onOpen();
                };
                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    console.log('WebSocket message received:', message);
                    if (this.onMessage) this.onMessage(message);
                };
                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateConnectionStatus('disconnected');
                    if (this.onClose) this.onClose();
                };
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('disconnected');
                    if (this.onError) this.onError(error);
                    showNotification('WebSocket error. Check console for details.', 'error');
                };
            }

            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                } else {
                    console.warn('WebSocket not open. Message not sent:', data);
                    showNotification('Connection not ready. Please try again.', 'error');
                }
            }

            close() {
                if (this.ws) {
                    this.ws.close();
                }
            }
        }

        function updateConnectionStatus(status) {
            const statusElement = DOM.connectionStatus;
            statusElement.className = `connection-status ${status}`;
            statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            DOM.notificationContainer.appendChild(notification);

            // Trigger reflow to enable transition
            void notification.offsetWidth;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove());
            }, duration);
        }

        // --- Session and Game Logic ---
        async function createSession() {
            playerName = DOM.playerNameInput.value.trim();
            if (!playerName) {
                showNotification('Please enter your name.', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/create-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerName })
                });
                const data = await response.json();
                if (response.ok) {
                    sessionId = data.sessionId;
                    showNotification(`Session created! ID: ${sessionId}`, 'success');
                    connectToWebSocket(sessionId, playerName);
                    displaySessionControls();
                } else {
                    throw new Error(data.error || 'Failed to create session');
                }
            } catch (error) {
                console.error('Error creating session:', error);
                showNotification(`Error creating session: ${error.message}`, 'error');
            }
        }

        async function joinSession() {
            playerName = DOM.playerNameInput.value.trim();
            sessionId = DOM.sessionIdInput.value.trim();
            if (!playerName || !sessionId) {
                showNotification('Please enter your name and session ID.', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/join-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId, playerName })
                });
                const data = await response.json();
                if (response.ok) {
                    showNotification(`Joined session: ${sessionId}`, 'success');
                    connectToWebSocket(sessionId, playerName);
                    displaySessionControls();
                } else {
                    throw new Error(data.error || 'Failed to join session');
                }
            } catch (error) {
                console.error('Error joining session:', error);
                showNotification(`Error joining session: ${error.message}`, 'error');
            }
        }

        function connectToWebSocket(sId, pName) {
            if (gameWebSocket) {
                gameWebSocket.close(); // Close existing connection if any
            }
            const wsUrl = `${WS_BASE_URL}?sessionId=${sId}&playerName=${pName}`;
            gameWebSocket = new GameWebSocket(
                wsUrl,
                () => { /* onOpen, no specific action here */ },
                handleWebSocketMessage,
                () => { /* onClose, no specific action here */ },
                () => { /* onError, handled by class */ }
            );
        }

        function displaySessionControls() {
            DOM.createJoinSessionSection.style.display = 'none';
            DOM.sessionDisplay.style.display = 'block';
            DOM.sessionIdDisplay.textContent = sessionId;
        }

        function startGame() {
            gameWebSocket.send({ type: 'start_game' });
        }

        function copySessionId() {
            navigator.clipboard.writeText(sessionId)
                .then(() => showNotification('Session ID copied to clipboard!', 'success'))
                .catch(err => showNotification('Failed to copy session ID.', 'error'));
        }

        function handleWebSocketMessage(message) {
            switch (message.type) {
                case 'session_update':
                    sessionData = message.data;
                    handleSessionUpdate(sessionData);
                    break;
                case 'player_kicked':
                    showNotification(`${message.playerName} was kicked!`, 'info');
                    // Refresh player list to reflect the kicked status
                    if (sessionData && sessionData.players) {
                        const kickedPlayer = sessionData.players.find(p => p.id === message.playerId);
                        if (kickedPlayer) {
                            kickedPlayer.status = 'kicked'; // Mark client-side as kicked
                        }
                    }
                    updateLivePlayersList();
                    break;
                case 'game_start':
                    showNotification('Game started!', 'success');
                    showGameScreen();
                    resetGameUI();
                    break;
                case 'new_round':
                    showNotification(`Round ${message.data.roundNumber} started!`, 'info');
                    resetGameUI();
                    updateGameStatus(`Round ${message.data.roundNumber} - Guess the location!`);
                    // NEW: You might trigger client-side kickout here or after a round ends
                    // For example: if (message.data.roundEnded) performBattleRoyaleClientKickout();
                    break;
                case 'round_end':
                    showNotification('Round ended! Calculating scores...', 'info');
                    updateGameStatus('Round ended!');
                    hideOverlayMap();
                    // Display real location and score for the round
                    actualLocationCoords = message.data.actualLocation;
                    if (actualLocationCoords) {
                        displayRealLocationPin(actualLocationCoords);
                    }
                    if (message.data.roundScores) {
                        updateGameStatus(`Your score this round: ${message.data.roundScores[getPlayerId()] || 0} pts`);
                    }
                    // NEW: This is a good place to trigger client-side kickout
                    // based on round end and current player data
                    if (message.data.isBattleRoyaleRoundEnd) { // Assume server sends this flag
                        performBattleRoyaleClientKickout();
                    }
                    break;
                case 'game_end':
                    showNotification('Game ended! Final scores...', 'success');
                    updateGameStatus('Game Over!');
                    hideGameScreen();
                    showLeaderboard(message.data.finalScores);
                    break;
                case 'error':
                    showNotification(`Error: ${message.message}`, 'error');
                    break;
                case 'kickout_countdown': // NEW: If server provides countdown info
                    updateBattleRoyaleUI(sessionData.players.length, message.data.timeLeft);
                    break;
                case 'player_eliminated': // NEW: If server sends specific elimination event
                    showNotification(`${message.playerName} was eliminated!`, 'info');
                    // Find and mark player as eliminated in sessionData
                    if (sessionData && sessionData.players) {
                        const eliminatedPlayer = sessionData.players.find(p => p.id === message.playerId);
                        if (eliminatedPlayer) {
                            eliminatedPlayer.status = 'eliminated';
                        }
                    }
                    updateLivePlayersList(); // Refresh UI
                    // Update battle royale status
                    updateBattleRoyaleUI(sessionData.players.filter(p => p.status !== 'eliminated' && p.status !== 'kicked' && p.status !== 'left').length, null);
                    break;
            }
        }

        function handleSessionUpdate(data) {
            DOM.sessionIdDisplay.textContent = data.sessionId;
            if (data.status === 'waiting') {
                DOM.waitingRoom.style.display = 'block';
                DOM.startGameBtn.style.display = data.isHost ? 'block' : 'none';
                DOM.gameScreen.style.display = 'none';
                DOM.leaderboardSection.style.display = 'none';
            } else if (data.status === 'in-game') {
                showGameScreen();
                DOM.waitingRoom.style.display = 'none';
                DOM.leaderboardSection.style.display = 'none';
                updateGameStatus(`Round ${data.roundNumber} - Guess the location!`);
            } else if (data.status === 'finished') {
                hideGameScreen();
                DOM.waitingRoom.style.display = 'none';
                showLeaderboard(data.finalScores);
            }
            updateLivePlayersList();
        }

        function updateGameStatus(message) {
            DOM.gameStatusBar.textContent = message;
        }

        // NEW: Update Battle Royale UI for players remaining and time
        function updateBattleRoyaleUI(playersLeft, timeLeft) {
            if (DOM.playersRemaining) DOM.playersRemaining.textContent = playersLeft;
            if (DOM.timeRemaining) {
                if (timeLeft !== null) {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    DOM.timeRemaining.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    DOM.timeRemaining.textContent = '--:--'; // Clear if no time provided
                }
            }
        }


        function updateLivePlayersList() {
            if (!sessionData || !sessionData.players) return;

            let html = '';
            const playerId = getPlayerId(); // Get current player's ID

            sessionData.players.forEach(player => {
                const isCurrentPlayer = player.id === playerId;
                let statusClass = '';
                if (player.status === 'active') {
                    statusClass = '';
                } else if (player.status === 'eliminated') { // NEW: Handle 'eliminated' status
                    statusClass = 'eliminated';
                } else {
                    statusClass = player.status; // 'left', 'kicked'
                }
                if (isCurrentPlayer) statusClass += ' you';

                html += `<div class="player-item ${statusClass}">
                    <div>
                        <strong>${player.name}</strong>${isCurrentPlayer ? ' (You)' : ''} - ${player.status}
                        ${player.note ? ` - <em>${player.note}</em>` : ''}
                    </div>
                    <div>${player.score || 0} pts</div>
                </div>`;
            });
            DOM.livePlayerList.innerHTML = html;
            // Update the Battle Royale players remaining count
            const activePlayers = sessionData.players.filter(p => p.status === 'active');
            updateBattleRoyaleUI(activePlayers.length, null); // Time left should come from server
        }

        function showGameScreen() {
            DOM.gameScreen.style.display = 'block';
            DOM.createJoinSessionSection.style.display = 'none';
            DOM.sessionDisplay.style.display = 'block';
            DOM.leaderboardSection.style.display = 'none';
            initializeMaps();
        }

        function hideGameScreen() {
            DOM.gameScreen.style.display = 'none';
        }

        function resetGameUI() {
            // Reset map pins and line
            if (guessPinElement) guessPinElement.style.display = 'none';
            if (realLocationPinElement) realLocationPinElement.style.display = 'none';
            if (lineBetweenPinsElement) lineBetweenPinsElement.style.display = 'none';
            userGuessLngLat = null;
            actualLocationCoords = null;
            DOM.locationText.textContent = 'Guess the location!';
            DOM.submitGuessBtn.disabled = true;
            showOverlayMap();
        }

        function showLeaderboard(finalScores) {
            DOM.leaderboardSection.style.display = 'block';
            let html = '';
            const sortedScores = Object.entries(finalScores)
                .map(([id, score]) => ({ id, score, name: sessionData.players.find(p => p.id === id)?.name || 'Unknown' }))
                .sort((a, b) => b.score - a.score);

            sortedScores.forEach((player, index) => {
                const isFirst = index === 0 ? 'first' : '';
                html += `<div class="leaderboard-item ${isFirst}">
                    <div>${index + 1}. <strong>${player.name}</strong></div>
                    <div>${player.score} pts</div>
                </div>`;
            });
            DOM.leaderboardList.innerHTML = html;
        }

        function getPlayerId() {
            // This is a client-side UUID, needs to be consistently set and retrieved
            // For now, let's assume it's part of the session data passed on join/create
            // You might need a more robust way to manage player IDs
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('playerId') || localStorage.getItem('playerId');
        }

        // --- Map Handling ---
        function initializeMaps() {
            if (map) return; // Maps already initialized

            try {
                map = new maptilersdk.Map({
                    container: DOM.mapElement,
                    style: maptilersdk.MapStyle.STREETS,
                    center: [0, 0], // Default center
                    zoom: 1
                });

                overlayMap = new maptilersdk.Map({
                    container: DOM.overlayMapElement,
                    style: maptilersdk.MapStyle.STREETS,
                    center: [0, 0], // Default center
                    zoom: 1,
                    interactive: true // Make overlay interactive for placing pins
                });

                guessPinElement = DOM.guessPin;
                realLocationPinElement = DOM.realLocationPin;
                lineBetweenPinsElement = DOM.lineBetweenPins;

                overlayMap.on('load', () => {
                    overlayMap.on('click', placeGuessPinHandler);
                    overlayMap.on('contextmenu', placeGuessPinHandler);
                });

                // Handle overlay map transitions
                DOM.overlayMapElement.addEventListener('transitionend', () => {
                    if (overlayMap) {
                        overlayMap.resize();
                        if (guessPinElement && userGuessLngLat) updateGuessPinPositionHandler();
                        if (realLocationPinElement && actualLocationCoords) updateRealLocationPinPositionHandler();
                        updateLineBetweenPins();
                    }
                });

                // Add submit button handler
                DOM.submitGuessBtn.addEventListener('click', submitGuess);

                console.log('Maps initialized successfully');
                
            } catch (error) {
                console.error('Failed to initialize maps:', error);
                DOM.locationText.textContent = `Failed to load maps: ${error.message}`;
            }
        }

        function showOverlayMap() {
            DOM.overlayMapElement.classList.add('active');
        }

        function hideOverlayMap() {
            DOM.overlayMapElement.classList.remove('active');
        }

        function placeGuessPinHandler(e) {
            userGuessLngLat = e.lngLat;
            updateGuessPinPositionHandler();
            DOM.submitGuessBtn.disabled = false;
        }

        function updateGuessPinPositionHandler() {
            if (userGuessLngLat && guessPinElement) {
                const pixelCoords = overlayMap.project(userGuessLngLat);
                guessPinElement.style.left = `${pixelCoords.x}px`;
                guessPinElement.style.top = `${pixelCoords.y}px`;
                guessPinElement.style.display = 'block';
                updateLineBetweenPins();
            }
        }

        function displayRealLocationPin(lngLat) {
            actualLocationCoords = lngLat;
            updateRealLocationPinPositionHandler();
        }

        function updateRealLocationPinPositionHandler() {
            if (actualLocationCoords && realLocationPinElement) {
                const pixelCoords = map.project(actualLocationCoords);
                realLocationPinElement.style.left = `${pixelCoords.x}px`;
                realLocationPinElement.style.top = `${pixelCoords.y}px`;
                realLocationPinElement.style.display = 'block';
                updateLineBetweenPins();
            }
        }

        function updateLineBetweenPins() {
            if (userGuessLngLat && actualLocationCoords && lineBetweenPinsElement) {
                const guessPixel = overlayMap.project(userGuessLngLat);
                const realPixel = map.project(actualLocationCoords); // Use base map for real location

                const dx = realPixel.x - guessPixel.x;
                const dy = realPixel.y - guessPixel.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                lineBetweenPinsElement.style.width = `${distance}px`;
                lineBetweenPinsElement.style.transform = `translate(${guessPixel.x}px, ${guessPixel.y}px) rotate(${angle}deg)`;
                lineBetweenPinsElement.style.display = 'block';
            } else {
                lineBetweenPinsElement.style.display = 'none';
            }
        }

        function submitGuess() {
            if (!userGuessLngLat) {
                showNotification('Please place your guess pin on the map.', 'error');
                return;
            }
            gameWebSocket.send({
                type: 'submit_guess',
                guess: {
                    lng: userGuessLngLat.lng,
                    lat: userGuessLngLat.lat
                }
            });
            DOM.submitGuessBtn.disabled = true;
        }

        // --- NEW: Client-side Battle Royale Kickout Logic ---
        function performBattleRoyaleClientKickout() {
            if (!sessionData || !sessionData.players || sessionData.players.length <= 1) {
                console.log("Not enough players for battle royale kickout or session data missing.");
                return;
            }

            // Filter for active players who can be kicked
            const activePlayers = sessionData.players.filter(p => p.status === 'active');
            if (activePlayers.length <= 1) {
                console.log("Only one or zero active players remaining, no kickout needed.");
                return;
            }

            // Sort players by score in ascending order for elimination
            // Assuming higher score is better, so lower scores get kicked
            const playersForElimination = [...activePlayers].sort((a, b) => a.score - b.score);

            const numPlayersToKick = Math.floor(playersForElimination.length / 2); // Half the people
            let actualPlayersToKick = numPlayersToKick;

            // Apply the "if uneven like 3, kickout half but 1 less, like in the case of 3, kick 1" rule
            if (playersForElimination.length % 2 !== 0 && numPlayersToKick > 0) {
                actualPlayersToKick = numPlayersToKick - 1; // If 3 players, numPlayersToKick = 1, actual = 0. This rule is a bit ambiguous.
                                                            // Reinterpreting "kickout half but 1 less" when odd:
                                                            // e.g., 3 players -> half = 1.5 -> floor = 1. "1 less" would mean 0.
                                                            // A more common BR rule for odd numbers is to kick 'floor(N/2)' or 'ceil(N/2)'
                                                            // Let's stick to the interpretation of "kickout half (rounded down) but 1 less if odd"
                                                            // For 3 players, floor(3/2) = 1. 1 less is 0. So 1 player is safe.
                                                            // If 5 players, floor(5/2) = 2. 1 less is 1. So 4 players are safe.
                                                            // This rule effectively means `floor(N/2) - 1` if N is odd and > 1.
                                                            // Or, simpler, `ceil(N/2)` players survive.
                                                            // If N=3, ceil(3/2) = 2 survive, 1 kicked. So 1 player kicked.
                                                            // If N=5, ceil(5/2) = 3 survive, 2 kicked. So 2 players kicked.
                                                            // Let's go with the more common 'kick `floor(N/2)`' behavior for even, and `floor(N/2)` for odd,
                                                            // which means `N - ceil(N/2)` kicked.
                                                            // User's specific rule: "if uneven like 3, kickout half but 1 less, like in the case of 3, kick 1".
                                                            // This means if 3 players, kick 1. (3/2 = 1.5, floor = 1). So 1 kicked.
                                                            // If 5 players, (5/2 = 2.5, floor = 2). The rule "but 1 less" might apply, making it 1 kicked.
                                                            // This rule is unusual. If "kickout half but 1 less" means take `floor(N/2)` then subtract 1 if N is odd,
                                                            // for 3 players, floor(3/2) = 1, 1 - 1 = 0 kicked.
                                                            // For 5 players, floor(5/2) = 2, 2 - 1 = 1 kicked.
                                                            // This seems to contradict "kick 1" for 3 players.

            // Let's re-interpret the user's explicit example: "in the case of 3, kick 1".
            // If N=3, want to kick 1.
            // If N=even, want to kick N/2.
            // This means: `Math.floor(activePlayers.length / 2)` players are kicked.
            // This covers "half the people" for even numbers.
            // For 3 players, Math.floor(3/2) = 1. This matches "kick 1".
            // So, `Math.floor(activePlayers.length / 2)` seems to be the consistent rule.
            actualPlayersToKick = Math.floor(playersForElimination.length / 2);

            if (actualPlayersToKick === 0) {
                console.log("No players to kick based on current rules.");
                return;
            }

            const kickedPlayers = playersForElimination.slice(0, actualPlayersToKick);

            kickedPlayers.forEach(player => {
                // Find the player in the main sessionData.players array and update their status
                const originalPlayer = sessionData.players.find(p => p.id === player.id);
                if (originalPlayer) {
                    originalPlayer.status = 'eliminated';
                    showNotification(`${originalPlayer.name} has been eliminated!`, 'info');
                    // If the kicked player is *this* client, close their WebSocket
                    // This simulates being kicked from the game.
                    if (originalPlayer.id === getPlayerId()) {
                        showNotification("You have been eliminated!", 'error', 5000);
                        if (gameWebSocket) {
                            gameWebSocket.close(); // Disconnect client from WebSocket
                        }
                        // Optionally, redirect to a game over screen or disable further interaction
                        hideGameScreen();
                        DOM.sessionDisplay.style.display = 'none';
                        showLeaderboard(sessionData.finalScores || {}); // Show current scores as "final"
                    }
                }
            });

            // Update the UI to reflect the changes
            updateLivePlayersList();
            updateBattleRoyaleUI(sessionData.players.filter(p => p.status === 'active').length, null);

            console.log(`Battle Royale: Kicked ${kickedPlayers.length} players.`);
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements();
            updateConnectionStatus('disconnected');

            // Retrieve player name and session ID from localStorage or URL params
            const savedPlayerName = localStorage.getItem('playerName');
            if (savedPlayerName) {
                DOM.playerNameInput.value = savedPlayerName;
                playerName = savedPlayerName;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const urlSessionId = urlParams.get('sessionId');
            const urlPlayerId = urlParams.get('playerId'); // If you plan to pass player ID in URL
            if (urlSessionId) {
                DOM.sessionIdInput.value = urlSessionId;
                sessionId = urlSessionId;
                // If sessionId and playerName are present, auto-join
                if (playerName) {
                    joinSession();
                }
            }

            // Event Listeners
            DOM.createSessionBtn.addEventListener('click', createSession);
            DOM.joinSessionBtn.addEventListener('click', joinSession);
            DOM.startGameBtn.addEventListener('click', startGame);
            DOM.copySessionIdBtn.addEventListener('click', copySessionId);
            DOM.newGameBtn.addEventListener('click', () => {
                // Reset UI to allow creating/joining new session
                location.reload(); // Simple reload for fresh start
            });

            // Store player name for next visit
            DOM.playerNameInput.addEventListener('change', (e) => {
                localStorage.setItem('playerName', e.target.value);
            });
        });

        // --- Cleanup on page unload ---
        window.addEventListener('beforeunload', () => {
            if (gameWebSocket) {
                gameWebSocket.close();
            }
        });
    </script>
</body>
</html>
